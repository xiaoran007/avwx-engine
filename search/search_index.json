{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AVWX AVWX is a global aviation weather fetching and parsing engine. It sources reports from a variety of government sources, parses individual elements, and calculates additional information like flight rules and time range interpolation. AVWX currently supports: Station data and search METAR TAF PIREP NBM (NBH, NBS, NBE) GFS (MAV, MEX) >>> import avwx >>> jfk_metar = avwx . Metar ( 'KJFK' ) >>> jfk_metar . update () True >>> jfk_metar . data . flight_rules 'VFR' These docs could use some love, and I am not a writer. You can help by making a pull request on GitHub Contents Getting Started Aviation Reports METAR TAF PIREP Model Forecasts NBM NBH NBM NBS NBM NBE GFS MOS MAV GFS MOS MEX Utilities Station Service Other Data Structures Static Values Exceptions","title":"AVWX"},{"location":"#avwx","text":"AVWX is a global aviation weather fetching and parsing engine. It sources reports from a variety of government sources, parses individual elements, and calculates additional information like flight rules and time range interpolation. AVWX currently supports: Station data and search METAR TAF PIREP NBM (NBH, NBS, NBE) GFS (MAV, MEX) >>> import avwx >>> jfk_metar = avwx . Metar ( 'KJFK' ) >>> jfk_metar . update () True >>> jfk_metar . data . flight_rules 'VFR' These docs could use some love, and I am not a writer. You can help by making a pull request on GitHub","title":"AVWX"},{"location":"#contents","text":"Getting Started","title":"Contents"},{"location":"#aviation-reports","text":"METAR TAF PIREP","title":"Aviation Reports"},{"location":"#model-forecasts","text":"NBM NBH NBM NBS NBM NBE GFS MOS MAV GFS MOS MEX","title":"Model Forecasts"},{"location":"#utilities","text":"Station Service Other Data Structures Static Values Exceptions","title":"Utilities"},{"location":"getting-started/","text":"Getting Started Installation AVWX is available on PyPI. Note: the package name is avwx-engine , but the import is avwx pip install avwx-engine AVWX only supports Python 3.7 and above. Tutorial Let's run through a quick example of fetching and parsing a METAR and TAF. There are other report types, but they follow the same basic API. >>> import avwx >>> jfk_metar = avwx . Metar ( 'KJFK' ) >>> jfk_metar . update () True >>> jfk_metar . raw 'KJFK 281651Z 33021G25KT 10SM FEW060 M08/M23 A3054 RMK AO2 SLP339 T10831228' >>> jfk_metar . data . flight_rules 'VFR' >>> jfk_metar . summary 'Winds NNW-330 at 21kt gusting to 25kt, Vis 10sm, Temp -08C, Dew -23C, Alt 30.54inHg, Few clouds at 6000ft' >>> jfk_metar . station . name 'John F Kennedy International Airport' Here, we create a METAR object and initialize it to pull data for JFK International airport. The update call fetches the current report, parses it into its individual components, and formats the translations. We then view the original report, the calculated flight rules, and a summary string from the translations. We can also see details of the station if available. >>> hnl_taf = avwx . Taf ( 'PHNL' ) >>> hnl_taf . update () True >>> hnl_taf . raw 'PHNL 312058Z 3121/0124 07012G19KT P6SM FEW030 SCT050 FM010500 06007KT P6SM FEW025 SCT045 FM012000 07012G19KT P6SM OVC030 SCT050' >>> len ( hnl_taf . data . forecast ) 3 >>> for line in hnl_taf . data . forecast : ... print ( f \" { line . flight_rules } from { line . start_time . dt . strftime ( ' %d -%H:%M' ) } to { line . end_time . dt . strftime ( ' %d -%H:%M' ) } \" ) ... VFR from 31 - 21 : 00 to 01 - 05 : 00 VFR from 01 - 05 : 00 to 01 - 20 : 00 MVFR from 01 - 20 : 00 to 01 - 24 : 00 Here we start of the same with the Taf object, this time for Honolulu. Because TAFs are forecasts, they contain multiple time periods. Here, we have three: a base and two amendments. Our code shows the different forecasted flight rules for each time period (day-hour). Taf objects have most of the same attributes as Metar objects, so we could also grab the station info if we needed to.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"AVWX is available on PyPI. Note: the package name is avwx-engine , but the import is avwx pip install avwx-engine AVWX only supports Python 3.7 and above.","title":"Installation"},{"location":"getting-started/#tutorial","text":"Let's run through a quick example of fetching and parsing a METAR and TAF. There are other report types, but they follow the same basic API. >>> import avwx >>> jfk_metar = avwx . Metar ( 'KJFK' ) >>> jfk_metar . update () True >>> jfk_metar . raw 'KJFK 281651Z 33021G25KT 10SM FEW060 M08/M23 A3054 RMK AO2 SLP339 T10831228' >>> jfk_metar . data . flight_rules 'VFR' >>> jfk_metar . summary 'Winds NNW-330 at 21kt gusting to 25kt, Vis 10sm, Temp -08C, Dew -23C, Alt 30.54inHg, Few clouds at 6000ft' >>> jfk_metar . station . name 'John F Kennedy International Airport' Here, we create a METAR object and initialize it to pull data for JFK International airport. The update call fetches the current report, parses it into its individual components, and formats the translations. We then view the original report, the calculated flight rules, and a summary string from the translations. We can also see details of the station if available. >>> hnl_taf = avwx . Taf ( 'PHNL' ) >>> hnl_taf . update () True >>> hnl_taf . raw 'PHNL 312058Z 3121/0124 07012G19KT P6SM FEW030 SCT050 FM010500 06007KT P6SM FEW025 SCT045 FM012000 07012G19KT P6SM OVC030 SCT050' >>> len ( hnl_taf . data . forecast ) 3 >>> for line in hnl_taf . data . forecast : ... print ( f \" { line . flight_rules } from { line . start_time . dt . strftime ( ' %d -%H:%M' ) } to { line . end_time . dt . strftime ( ' %d -%H:%M' ) } \" ) ... VFR from 31 - 21 : 00 to 01 - 05 : 00 VFR from 01 - 05 : 00 to 01 - 20 : 00 MVFR from 01 - 20 : 00 to 01 - 24 : 00 Here we start of the same with the Taf object, this time for Honolulu. Because TAFs are forecasts, they contain multiple time periods. Here, we have three: a base and two amendments. Our code shows the different forecasted flight rules for each time period (day-hour). Taf objects have most of the same attributes as Metar objects, so we could also grab the station info if we needed to.","title":"Tutorial"},{"location":"av/metar/","text":"METAR A METAR (Meteorological Aerodrome Report) is the surface weather observed at most controlled (and some uncontrolled) airports. They are updated once per hour or when conditions change enough to warrant an update, and the observations are valid for one hour after the report was issued or until the next report is issued. class avwx. Metar ( icao: str ) The Metar class offers an object-oriented approach to managing METAR data for a single station. Below is typical usage for fetching and pulling METAR data for KJFK. >>> from avwx import Metar >>> kjfk = Metar ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2018 , 3 , 4 , 23 , 36 , 6 , 62376 ) >>> kjfk . raw 'KJFK 042251Z 32023G32KT 10SM BKN060 04/M08 A3008 RMK AO2 PK WND 32032/2251 SLP184 T00441078' >>> kjfk . data . flight_rules 'VFR' >>> kjfk . translations . remarks { 'AO2' : 'Automated with precipitation sensor' , 'SLP184' : 'Sea level pressure: 1018.4 hPa' , 'T00441078' : 'Temperature 4.4\u00b0C and dewpoint -7.8\u00b0C' } The parse and from_report methods can parse a report string if you want to override the normal fetching process. Here's an example of a really bad day. >>> from avwx import Metar >>> report = 'KSFO 031254Z 36024G55KT 320V040 1/8SM R06/0200D +TS VCFC OVC050 BKN040TCU 14/10 A2978 RMK AIRPORT CLOSED' >>> ksfo = Metar . from_report ( report ) True >>> ksfo . station . city 'San Francisco' >>> ksfo . last_updated datetime . datetime ( 2018 , 3 , 4 , 23 , 54 , 4 , 353757 ) >>> ksfo . data . flight_rules 'LIFR' >>> ksfo . translations . clouds 'Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft - Reported AGL' >>> ksfo . summary 'Winds N-360 (variable 320 to 040) at 24kt gusting to 55kt, Vis 0.125sm, Temp 14C, Dew 10C, Alt 29.78inHg, Heavy Thunderstorm, Vicinity Funnel Cloud, Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft' async async_update ( timeout: int = 10 ) -> bool Async updates report data by fetching and parsing the report Returns True if a new report is available, else False data : avwx.structs.MetarData = None MetarData dataclass of parsed data values and units. Parsed on update() from_report ( report: str ) -> avwx.Metar Returns an updated report object based on an existing report icao : str 4-character ICAO station ident code the report was initialized with issued : date = None UTC date object when the report was issued last_updated : datetime.datetime = None UTC Datetime object when the report was last updated parse ( report: str , issued: Optional[date] = None ) -> bool Updates report data by parsing a given report Can accept a report issue date if not a recent report string raw : str = None The unparsed report string. Fetched on update() service : avwx.service.Service Service object used to fetch the report string source : str = None Source URL root used to pull the current report data speech : str Report summary designed to be read by a text-to-speech program station : avwx.Station Provides basic station info summary : str Condensed report summary created from translations translations : avwx.structs.MetarTrans = None MetarTrans dataclass of translation strings from data. Parsed on update() units : avwx.structs.Units Units inferred from the station location and report contents update ( timeout: int = 10 ) -> bool Updates report data by fetching and parsing the report Returns True if a new report is available, else False class avwx.structs. MetarData altimeter : avwx.structs.Number clouds : List[avwx.structs.Cloud] density_altitude : int dewpoint : avwx.structs.Number flight_rules : str other : List[str] pressure_altitude : int raw : str relative_humidity : str remarks : str remarks_info : avwx.structs.RemarksData runway_visibility : List[str] sanitized : str icao : str temperature : avwx.structs.Number time : avwx.structs.Timestamp visibility : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_speed : avwx.structs.Number wind_variable_direction : avwx.structs.Number class avwx.structs. MetarTrans altimeter : str clouds : str dewpoint : str other : str remarks : dict temperature : str visibility : str wind : str","title":"METAR"},{"location":"av/metar/#metar","text":"A METAR (Meteorological Aerodrome Report) is the surface weather observed at most controlled (and some uncontrolled) airports. They are updated once per hour or when conditions change enough to warrant an update, and the observations are valid for one hour after the report was issued or until the next report is issued.","title":"METAR"},{"location":"av/metar/#class-avwxmetaricao-str","text":"The Metar class offers an object-oriented approach to managing METAR data for a single station. Below is typical usage for fetching and pulling METAR data for KJFK. >>> from avwx import Metar >>> kjfk = Metar ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2018 , 3 , 4 , 23 , 36 , 6 , 62376 ) >>> kjfk . raw 'KJFK 042251Z 32023G32KT 10SM BKN060 04/M08 A3008 RMK AO2 PK WND 32032/2251 SLP184 T00441078' >>> kjfk . data . flight_rules 'VFR' >>> kjfk . translations . remarks { 'AO2' : 'Automated with precipitation sensor' , 'SLP184' : 'Sea level pressure: 1018.4 hPa' , 'T00441078' : 'Temperature 4.4\u00b0C and dewpoint -7.8\u00b0C' } The parse and from_report methods can parse a report string if you want to override the normal fetching process. Here's an example of a really bad day. >>> from avwx import Metar >>> report = 'KSFO 031254Z 36024G55KT 320V040 1/8SM R06/0200D +TS VCFC OVC050 BKN040TCU 14/10 A2978 RMK AIRPORT CLOSED' >>> ksfo = Metar . from_report ( report ) True >>> ksfo . station . city 'San Francisco' >>> ksfo . last_updated datetime . datetime ( 2018 , 3 , 4 , 23 , 54 , 4 , 353757 ) >>> ksfo . data . flight_rules 'LIFR' >>> ksfo . translations . clouds 'Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft - Reported AGL' >>> ksfo . summary 'Winds N-360 (variable 320 to 040) at 24kt gusting to 55kt, Vis 0.125sm, Temp 14C, Dew 10C, Alt 29.78inHg, Heavy Thunderstorm, Vicinity Funnel Cloud, Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft'","title":"class avwx.Metar(icao: str)"},{"location":"av/metar/#async-async_updatetimeout-int-10-bool","text":"Async updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"async async_update(timeout: int = 10) -&gt; bool"},{"location":"av/metar/#data-avwxstructsmetardata-none","text":"MetarData dataclass of parsed data values and units. Parsed on update()","title":"data: avwx.structs.MetarData = None"},{"location":"av/metar/#from_reportreport-str-avwxmetar","text":"Returns an updated report object based on an existing report","title":"from_report(report: str) -&gt; avwx.Metar"},{"location":"av/metar/#icao-str","text":"4-character ICAO station ident code the report was initialized with","title":"icao: str"},{"location":"av/metar/#issued-date-none","text":"UTC date object when the report was issued","title":"issued: date = None"},{"location":"av/metar/#last_updated-datetimedatetime-none","text":"UTC Datetime object when the report was last updated","title":"last_updated: datetime.datetime = None"},{"location":"av/metar/#parsereport-str-issued-optionaldate-none-bool","text":"Updates report data by parsing a given report Can accept a report issue date if not a recent report string","title":"parse(report: str, issued: Optional[date] = None) -&gt; bool"},{"location":"av/metar/#raw-str-none","text":"The unparsed report string. Fetched on update()","title":"raw: str = None"},{"location":"av/metar/#service-avwxserviceservice","text":"Service object used to fetch the report string","title":"service: avwx.service.Service"},{"location":"av/metar/#source-str-none","text":"Source URL root used to pull the current report data","title":"source: str = None"},{"location":"av/metar/#speech-str","text":"Report summary designed to be read by a text-to-speech program","title":"speech: str"},{"location":"av/metar/#station-avwxstation","text":"Provides basic station info","title":"station: avwx.Station"},{"location":"av/metar/#summary-str","text":"Condensed report summary created from translations","title":"summary: str"},{"location":"av/metar/#translations-avwxstructsmetartrans-none","text":"MetarTrans dataclass of translation strings from data. Parsed on update()","title":"translations: avwx.structs.MetarTrans = None"},{"location":"av/metar/#units-avwxstructsunits","text":"Units inferred from the station location and report contents","title":"units: avwx.structs.Units"},{"location":"av/metar/#updatetimeout-int-10-bool","text":"Updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"update(timeout: int = 10) -&gt; bool"},{"location":"av/metar/#class-avwxstructsmetardata","text":"altimeter : avwx.structs.Number clouds : List[avwx.structs.Cloud] density_altitude : int dewpoint : avwx.structs.Number flight_rules : str other : List[str] pressure_altitude : int raw : str relative_humidity : str remarks : str remarks_info : avwx.structs.RemarksData runway_visibility : List[str] sanitized : str icao : str temperature : avwx.structs.Number time : avwx.structs.Timestamp visibility : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_speed : avwx.structs.Number wind_variable_direction : avwx.structs.Number","title":"class avwx.structs.MetarData"},{"location":"av/metar/#class-avwxstructsmetartrans","text":"altimeter : str clouds : str dewpoint : str other : str remarks : dict temperature : str visibility : str wind : str","title":"class avwx.structs.MetarTrans"},{"location":"av/pirep/","text":"PIREP A PIREP (Pilot Report) is an observation made by pilots inflight meant to aid controllers and pilots routing around adverse conditions and other conditions of note. They typically contain icing, turbulence, cloud types/bases/tops, and other info at a known distance and radial from a ground station. They are released as they come in. class avwx. Pireps ( icao: str = None, lat: float = None, lon: float = None ) The Pireps class offers an object-oriented approach to managing multiple PIREP reports for a single station. Below is typical usage for fetching and pulling PIREP data for KJFK. >>> from avwx import Pireps >>> kmco = Pireps ( 'KMCO' ) >>> kmco . station . name 'Orlando International Airport' >>> kmco . update () True >>> kmco . last_updated datetime . datetime ( 2019 , 5 , 24 , 13 , 31 , 46 , 561732 ) >>> kmco . raw [ 0 ] 'FLL UA /OV KFLL275015/TM 1241/FL020/TP B737/SK TOP020/RM DURD RY10L' >>> kmco . data [ 0 ] . location Location ( repr = 'KFLL275015' , station = 'KFLL' , direction = Number ( repr = '275' , value = 275 , spoken = 'two seven five' ), distance = Number ( repr = '015' , value = 15 , spoken = 'one five' )) The parse and from_report methods can parse a report string if you want to override the normal fetching process. Here's an example of a really bad day. >>> from avwx import Metar >>> ksfo = Metar . from_report ( report ) True >>> ksfo . station . city 'San Francisco' >>> ksfo . last_updated datetime . datetime ( 2018 , 3 , 4 , 23 , 54 , 4 , 353757 ) >>> ksfo . data . flight_rules 'LIFR' >>> ksfo . translations . clouds 'Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft - Reported AGL' >>> ksfo . summary 'Winds N-360 (variable 320 to 040) at 24kt gusting to 55kt, Vis 0.125sm, Temp 14C, Dew 10C, Alt 29.78inHg, Heavy Thunderstorm, Vicinity Funnel Cloud, Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft' async async_update ( timeout: int = 10 ) -> bool Async updates report data by fetching and parsing the report Returns True if a new report is available, else False data : List[avwx.structs.PirepData] = None List of PirepData dataclasses of parsed data values and units. Parsed on update() issued : date = None UTC date object when the report was issued last_updated : datetime.datetime = None UTC Datetime object when the reports were last updated lat : float Latitude of the radial center. This is supplied by the user or loaded from the station lon : float Longitude of the radial center. This is supplied by the user or loaded from the station parse ( reports: Union[str, List[str]] , issued: Optional[date] = None ) -> bool Updates report data by parsing a given report Can accept a report issue date if not a recent report string raw : List[str] = None The unparsed report strings. Fetched on update() service : avwx.service.Service Service object used to fetch the report strings source : str = None Source URL root used to pull the current report data station : avwx.Station = None Provides basic station info units : avwx.structs.Units Units inferred from the station location and report contents update ( timeout: int = 10 ) -> bool Updates report data by fetching and parsing recent aircraft reports Returns True if a new report is available, else False class avwx.structs. PirepData aircraft : avwx.structs.Aircraft = None altitude : avwx.structs.Number = None clouds : List[avwx.structs.Cloud] flight_visibility : avwx.structs.Number = None icing : avwx.structs.Icing = None location : avwx.structs.Location = None raw : str remarks : str sanitized : str icao : str temperature : avwx.structs.Number = None time : avwx.structs.Timestamp turbulence : avwx.structs.Turbulence = None type : str wx : List[str]","title":"PIREP"},{"location":"av/pirep/#pirep","text":"A PIREP (Pilot Report) is an observation made by pilots inflight meant to aid controllers and pilots routing around adverse conditions and other conditions of note. They typically contain icing, turbulence, cloud types/bases/tops, and other info at a known distance and radial from a ground station. They are released as they come in.","title":"PIREP"},{"location":"av/pirep/#class-avwxpirepsicao-str-none-lat-float-none-lon-float-none","text":"The Pireps class offers an object-oriented approach to managing multiple PIREP reports for a single station. Below is typical usage for fetching and pulling PIREP data for KJFK. >>> from avwx import Pireps >>> kmco = Pireps ( 'KMCO' ) >>> kmco . station . name 'Orlando International Airport' >>> kmco . update () True >>> kmco . last_updated datetime . datetime ( 2019 , 5 , 24 , 13 , 31 , 46 , 561732 ) >>> kmco . raw [ 0 ] 'FLL UA /OV KFLL275015/TM 1241/FL020/TP B737/SK TOP020/RM DURD RY10L' >>> kmco . data [ 0 ] . location Location ( repr = 'KFLL275015' , station = 'KFLL' , direction = Number ( repr = '275' , value = 275 , spoken = 'two seven five' ), distance = Number ( repr = '015' , value = 15 , spoken = 'one five' )) The parse and from_report methods can parse a report string if you want to override the normal fetching process. Here's an example of a really bad day. >>> from avwx import Metar >>> ksfo = Metar . from_report ( report ) True >>> ksfo . station . city 'San Francisco' >>> ksfo . last_updated datetime . datetime ( 2018 , 3 , 4 , 23 , 54 , 4 , 353757 ) >>> ksfo . data . flight_rules 'LIFR' >>> ksfo . translations . clouds 'Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft - Reported AGL' >>> ksfo . summary 'Winds N-360 (variable 320 to 040) at 24kt gusting to 55kt, Vis 0.125sm, Temp 14C, Dew 10C, Alt 29.78inHg, Heavy Thunderstorm, Vicinity Funnel Cloud, Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft'","title":"class avwx.Pireps(icao: str = None, lat: float = None, lon: float = None)"},{"location":"av/pirep/#async-async_updatetimeout-int-10-bool","text":"Async updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"async async_update(timeout: int = 10) -&gt; bool"},{"location":"av/pirep/#data-listavwxstructspirepdata-none","text":"List of PirepData dataclasses of parsed data values and units. Parsed on update()","title":"data: List[avwx.structs.PirepData] = None"},{"location":"av/pirep/#issued-date-none","text":"UTC date object when the report was issued","title":"issued: date = None"},{"location":"av/pirep/#last_updated-datetimedatetime-none","text":"UTC Datetime object when the reports were last updated","title":"last_updated: datetime.datetime = None"},{"location":"av/pirep/#lat-float","text":"Latitude of the radial center. This is supplied by the user or loaded from the station","title":"lat: float"},{"location":"av/pirep/#lon-float","text":"Longitude of the radial center. This is supplied by the user or loaded from the station","title":"lon: float"},{"location":"av/pirep/#parsereports-unionstr-liststr-issued-optionaldate-none-bool","text":"Updates report data by parsing a given report Can accept a report issue date if not a recent report string","title":"parse(reports: Union[str, List[str]], issued: Optional[date] = None) -&gt; bool"},{"location":"av/pirep/#raw-liststr-none","text":"The unparsed report strings. Fetched on update()","title":"raw: List[str] = None"},{"location":"av/pirep/#service-avwxserviceservice","text":"Service object used to fetch the report strings","title":"service: avwx.service.Service"},{"location":"av/pirep/#source-str-none","text":"Source URL root used to pull the current report data","title":"source: str = None"},{"location":"av/pirep/#station-avwxstation-none","text":"Provides basic station info","title":"station: avwx.Station = None"},{"location":"av/pirep/#units-avwxstructsunits","text":"Units inferred from the station location and report contents","title":"units: avwx.structs.Units"},{"location":"av/pirep/#updatetimeout-int-10-bool","text":"Updates report data by fetching and parsing recent aircraft reports Returns True if a new report is available, else False","title":"update(timeout: int = 10) -&gt; bool"},{"location":"av/pirep/#class-avwxstructspirepdata","text":"aircraft : avwx.structs.Aircraft = None altitude : avwx.structs.Number = None clouds : List[avwx.structs.Cloud] flight_visibility : avwx.structs.Number = None icing : avwx.structs.Icing = None location : avwx.structs.Location = None raw : str remarks : str sanitized : str icao : str temperature : avwx.structs.Number = None time : avwx.structs.Timestamp turbulence : avwx.structs.Turbulence = None type : str wx : List[str]","title":"class avwx.structs.PirepData"},{"location":"av/taf/","text":"TAF A TAF (Terminal Aerodrome Forecast) is a 24-hour weather forecast for the area 5 statute miles from the reporting station. They are update once every three or six hours or when significant changes warrant an update, and the observations are valid for six hours or until the next report is issued class avwx. Taf ( icao: str ) The Taf class offers an object-oriented approach to managing TAF data for a single station. >>> from avwx import Taf >>> kjfk = Taf ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2018 , 3 , 4 , 23 , 43 , 26 , 209644 ) >>> kjfk . raw 'KJFK 042030Z 0421/0524 33016G27KT P6SM BKN045 FM051600 36016G22KT P6SM BKN040 FM052100 35013KT P6SM SCT035' >>> len ( kjfk . data . forecast ) 3 >>> kjfk . data . forecast [ 0 ] . flight_rules 'VFR' >>> kjfk . translations . forecast [ 0 ] . wind 'NNW-330 at 16kt gusting to 27kt' >>> kjfk . speech 'Starting on March 4th - From 21 to 16 zulu, Winds three three zero at 16kt gusting to 27kt. Visibility greater than six miles. Broken layer at 4500ft. From 16 to 21 zulu, Winds three six zero at 16kt gusting to 22kt. Visibility greater than six miles. Broken layer at 4000ft. From 21 to midnight zulu, Winds three five zero at 13kt. Visibility greater than six miles. Scattered clouds at 3500ft' The parse and from_report methods can parse a report string if you want to override the normal fetching process. >>> from avwx import Taf >>> report = \"TAF ZYHB 082300Z 0823/0911 VRB03KT 9999 SCT018 BKN120 TX14/0907Z TN04/0921Z FM090100 09015KT 9999 -SHRA WS020/13045KT SCT018 BKN120 BECMG 0904/0906 34008KT PROB30 TEMPO 0906/0911 7000 -RA SCT020 650104 530804 RMK FCST BASED ON AUTO OBS. NXT FCST BY 090600Z\" >>> zyhb = Taf . from_report ( report ) True >>> zyhb . station . city 'Hulan' >>> zyhb . data . remarks 'RMK FCST BASED ON AUTO OBS. NXT FCST BY 090600Z' >>> zyhb . summary [ - 1 ] 'Vis 7km, Light Rain, Scattered clouds at 2000ft, Frequent moderate turbulence in clear air from 8000ft to 12000ft, Moderate icing in clouds from 1000ft to 5000ft' async async_update ( timeout: int = 10 ) -> bool Async updates report data by fetching and parsing the report Returns True if a new report is available, else False data : avwx.structs.TafData = None TafData dataclass of parsed data values and units. Parsed on update() from_report ( report: str ) -> avwx.Taf Returns an updated report object based on an existing report icao : str 4-character ICAO station ident code the report was initialized with issued : date = None UTC date object when the report was issued last_updated : datetime.datetime = None UTC Datetime object when the report was last updated parse ( report: str , issued: Optional[date] = None ) -> bool Updates report data by parsing a given report Can accept a report issue date if not a recent report string raw : str = None The unparsed report string. Fetched on update() service : avwx.service.Service Service object used to fetch the report string source : str = None Source URL root used to pull the current report data speech : str Report summary designed to be read by a text-to-speech program station : avwx.Station Provides basic station info summary : [str] Condensed report summaries created from translations translations : avwx.structs.TafTrans TafTrans dataclass of translation strings from data. Parsed on update() units : avwx.structs.Units Units inferred from the station location and report contents update ( timeout: int = 10 ) -> bool Updates report data by fetching and parsing the report Returns True if a new report is available, else False class avwx.structs. TafData alts : str = None end_time : avwx.structs.Timestamp forecast : List[avwx.structs.TafLineData] max_temp : float = None min_temp : float = None raw : str remarks : str start_time : avwx.structs.Timestamp icao : str temps : List[str] = None time : avwx.structs.Timestamp class avwx.structs. TafTrans forecast : List[avwx.structs.TafLineTrans] max_temp : str min_temp : str remarks : dict class avwx.structs. TafLineData altimeter : avwx.structs.Number clouds : List[avwx.structs.Cloud] end_time : avwx.structs.Timestamp flight_rules : str icing : List[str] other : List[str] probability : avwx.structs.Number raw : str sanitized : str start_time : avwx.structs.Timestamp transition_start : avwx.structs.Timestamp turbulence : List[str] type : str visibility : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_shear : str wind_speed : avwx.structs.Number class avwx.structs. TafLineTrans altimeter : str clouds : str icing : str other : str turbulence : str visibility : str wind : str wind_shear : str","title":"TAF"},{"location":"av/taf/#taf","text":"A TAF (Terminal Aerodrome Forecast) is a 24-hour weather forecast for the area 5 statute miles from the reporting station. They are update once every three or six hours or when significant changes warrant an update, and the observations are valid for six hours or until the next report is issued","title":"TAF"},{"location":"av/taf/#class-avwxtaficao-str","text":"The Taf class offers an object-oriented approach to managing TAF data for a single station. >>> from avwx import Taf >>> kjfk = Taf ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2018 , 3 , 4 , 23 , 43 , 26 , 209644 ) >>> kjfk . raw 'KJFK 042030Z 0421/0524 33016G27KT P6SM BKN045 FM051600 36016G22KT P6SM BKN040 FM052100 35013KT P6SM SCT035' >>> len ( kjfk . data . forecast ) 3 >>> kjfk . data . forecast [ 0 ] . flight_rules 'VFR' >>> kjfk . translations . forecast [ 0 ] . wind 'NNW-330 at 16kt gusting to 27kt' >>> kjfk . speech 'Starting on March 4th - From 21 to 16 zulu, Winds three three zero at 16kt gusting to 27kt. Visibility greater than six miles. Broken layer at 4500ft. From 16 to 21 zulu, Winds three six zero at 16kt gusting to 22kt. Visibility greater than six miles. Broken layer at 4000ft. From 21 to midnight zulu, Winds three five zero at 13kt. Visibility greater than six miles. Scattered clouds at 3500ft' The parse and from_report methods can parse a report string if you want to override the normal fetching process. >>> from avwx import Taf >>> report = \"TAF ZYHB 082300Z 0823/0911 VRB03KT 9999 SCT018 BKN120 TX14/0907Z TN04/0921Z FM090100 09015KT 9999 -SHRA WS020/13045KT SCT018 BKN120 BECMG 0904/0906 34008KT PROB30 TEMPO 0906/0911 7000 -RA SCT020 650104 530804 RMK FCST BASED ON AUTO OBS. NXT FCST BY 090600Z\" >>> zyhb = Taf . from_report ( report ) True >>> zyhb . station . city 'Hulan' >>> zyhb . data . remarks 'RMK FCST BASED ON AUTO OBS. NXT FCST BY 090600Z' >>> zyhb . summary [ - 1 ] 'Vis 7km, Light Rain, Scattered clouds at 2000ft, Frequent moderate turbulence in clear air from 8000ft to 12000ft, Moderate icing in clouds from 1000ft to 5000ft'","title":"class avwx.Taf(icao: str)"},{"location":"av/taf/#async-async_updatetimeout-int-10-bool","text":"Async updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"async async_update(timeout: int = 10) -&gt; bool"},{"location":"av/taf/#data-avwxstructstafdata-none","text":"TafData dataclass of parsed data values and units. Parsed on update()","title":"data: avwx.structs.TafData = None"},{"location":"av/taf/#from_reportreport-str-avwxtaf","text":"Returns an updated report object based on an existing report","title":"from_report(report: str) -&gt; avwx.Taf"},{"location":"av/taf/#icao-str","text":"4-character ICAO station ident code the report was initialized with","title":"icao: str"},{"location":"av/taf/#issued-date-none","text":"UTC date object when the report was issued","title":"issued: date = None"},{"location":"av/taf/#last_updated-datetimedatetime-none","text":"UTC Datetime object when the report was last updated","title":"last_updated: datetime.datetime = None"},{"location":"av/taf/#parsereport-str-issued-optionaldate-none-bool","text":"Updates report data by parsing a given report Can accept a report issue date if not a recent report string","title":"parse(report: str, issued: Optional[date] = None) -&gt; bool"},{"location":"av/taf/#raw-str-none","text":"The unparsed report string. Fetched on update()","title":"raw: str = None"},{"location":"av/taf/#service-avwxserviceservice","text":"Service object used to fetch the report string","title":"service: avwx.service.Service"},{"location":"av/taf/#source-str-none","text":"Source URL root used to pull the current report data","title":"source: str = None"},{"location":"av/taf/#speech-str","text":"Report summary designed to be read by a text-to-speech program","title":"speech: str"},{"location":"av/taf/#station-avwxstation","text":"Provides basic station info","title":"station: avwx.Station"},{"location":"av/taf/#summary-str","text":"Condensed report summaries created from translations","title":"summary: [str]"},{"location":"av/taf/#translations-avwxstructstaftrans","text":"TafTrans dataclass of translation strings from data. Parsed on update()","title":"translations: avwx.structs.TafTrans"},{"location":"av/taf/#units-avwxstructsunits","text":"Units inferred from the station location and report contents","title":"units: avwx.structs.Units"},{"location":"av/taf/#updatetimeout-int-10-bool","text":"Updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"update(timeout: int = 10) -&gt; bool"},{"location":"av/taf/#class-avwxstructstafdata","text":"alts : str = None end_time : avwx.structs.Timestamp forecast : List[avwx.structs.TafLineData] max_temp : float = None min_temp : float = None raw : str remarks : str start_time : avwx.structs.Timestamp icao : str temps : List[str] = None time : avwx.structs.Timestamp","title":"class avwx.structs.TafData"},{"location":"av/taf/#class-avwxstructstaftrans","text":"forecast : List[avwx.structs.TafLineTrans] max_temp : str min_temp : str remarks : dict","title":"class avwx.structs.TafTrans"},{"location":"av/taf/#class-avwxstructstaflinedata","text":"altimeter : avwx.structs.Number clouds : List[avwx.structs.Cloud] end_time : avwx.structs.Timestamp flight_rules : str icing : List[str] other : List[str] probability : avwx.structs.Number raw : str sanitized : str start_time : avwx.structs.Timestamp transition_start : avwx.structs.Timestamp turbulence : List[str] type : str visibility : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_shear : str wind_speed : avwx.structs.Number","title":"class avwx.structs.TafLineData"},{"location":"av/taf/#class-avwxstructstaflinetrans","text":"altimeter : str clouds : str icing : str other : str turbulence : str visibility : str wind : str wind_shear : str","title":"class avwx.structs.TafLineTrans"},{"location":"gfs/mav/","text":"GFS MOS MAV The MAV report is a short-range forecast (6-72 hours) based on the Global Forecast System model output and is only valid for ICAO stations in the United States, Puerto Rico, and US Virgin Islands. Reports are published every six hours starting at 0000 UTC. class avwx. Mav ( icao: str ) The Mav class offers an object-oriented approach to managing MOS MAV data for a single station. Below is typical usage for fetching and pulling MAV data for KJFK. >>> from avwx import Mav >>> kjfk = Mav ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 4 , 20 , 1 , 7 , 7 , 393270 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK GFS MOS GUIDANCE 4/19/2020 1800 UTC DT /APR 20 /APR 21 /APR 22 HR 00 03 06 09 12 15 18 21 00 03 06 09 12 15 18 21 00 03 06 12 18 N/X 46 58 44 58 37 TMP 53 52 50 48 48 50 54 56 51 49 47 46 49 53 55 52 47 45 43 41 54 DPT 43 41 37 35 33 30 28 27 28 30 32 34 37 39 37 32 26 23 22 18 14 CLD OV OV OV OV OV OV OV SC FW CL CL FW BK OV OV OV BK FW CL FW SC WDR 20 22 26 35 02 03 02 02 34 19 20 18 18 18 18 23 29 30 29 29 28 WSP 20 13 07 08 11 14 14 11 05 03 04 06 11 19 25 21 22 25 20 19 22 P06 0 12 9 1 0 1 29 68 8 2 0 P12 12 9 2 69 15 Q06 0 0 0 0 0 0 0 2 0 0 0 Q12 0 0 0 2 0 T06 0/ 4 1/ 0 1/ 0 0/ 0 0/ 0 0/ 0 5/ 3 13/13 0/ 0 0/ 8 T12 1/ 2 0/ 0 9/ 6 14/13 1/ 8 POZ 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 POS 0 0 0 0 0 2 0 6 6 9 9 0 16 8 0 4 4 47 60 67 42 TYP R R R R R R R R R R R R R R R R R R S S R SNW 0 0 CIG 7 7 7 7 6 6 6 8 8 8 8 8 8 6 6 6 7 8 8 8 8 VIS 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7 7 7 7 OBV N N N N N N N N N N N N N N N N N N N N N \"\"\" >>> len ( kjfk . data . forecast ) 21 >>> kjfk . data . forecast [ 0 ] . ceiling Code ( repr = '7' , value = '6600 - 12,000 feet' ) The parse and from_report methods can parse a report string if you want to override the normal fetching process. async async_update ( timeout: int = 10 ) -> bool Async updates report data by fetching and parsing the report Returns True if a new report is available, else False data : avwx.structs.MavData = None MavData dataclass of parsed data values and units. Parsed on update() from_report ( report: str ) -> avwx.Mav Returns an updated report object based on an existing report icao : str 4-character ICAO station ident code the report was initialized with issued : date = None UTC date object when the report was issued last_updated : datetime.datetime = None UTC Datetime object when the report was last updated parse ( report: str ) -> bool Updates report data by parsing a given report raw : str = None The unparsed report string. Fetched on update() service : avwx.service.Service Service object used to fetch the report string source : str = None Source URL root used to pull the current report data station : avwx.Station Provides basic station info units : avwx.structs.Units Units inferred from the station location and report contents update ( timeout: int = 10 ) -> bool Updates report data by fetching and parsing the report Returns True if a new report is available, else False class avwx.structs. MavData forecast : List[avwx.structs.MavPeriod] raw : str station : str time : avwx.structs.Timestamp class avwx.structs. MavPeriod ceiling : avwx.structs.Code cloud : avwx.structs.Code dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number precip_amount_6 : avwx.structs.Code precip_amount_12 : avwx.structs.Code precip_chance_6 : avwx.structs.Number precip_chance_12 : avwx.structs.Number precip_type : avwx.structs.Code severe_storm_6 : avwx.structs.Number severe_storm_12 : avwx.structs.Number snow : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_6 : avwx.structs.Number thunderstorm_12 : avwx.structs.Number time : avwx.structs.Timestamp vis_obstruction : avwx.structs.Code visibility : avwx.structs.Code wind_direction : avwx.structs.Number wind_speed : avwx.structs.Number","title":"GFS MOS MAV"},{"location":"gfs/mav/#gfs-mos-mav","text":"The MAV report is a short-range forecast (6-72 hours) based on the Global Forecast System model output and is only valid for ICAO stations in the United States, Puerto Rico, and US Virgin Islands. Reports are published every six hours starting at 0000 UTC.","title":"GFS MOS MAV"},{"location":"gfs/mav/#class-avwxmavicao-str","text":"The Mav class offers an object-oriented approach to managing MOS MAV data for a single station. Below is typical usage for fetching and pulling MAV data for KJFK. >>> from avwx import Mav >>> kjfk = Mav ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 4 , 20 , 1 , 7 , 7 , 393270 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK GFS MOS GUIDANCE 4/19/2020 1800 UTC DT /APR 20 /APR 21 /APR 22 HR 00 03 06 09 12 15 18 21 00 03 06 09 12 15 18 21 00 03 06 12 18 N/X 46 58 44 58 37 TMP 53 52 50 48 48 50 54 56 51 49 47 46 49 53 55 52 47 45 43 41 54 DPT 43 41 37 35 33 30 28 27 28 30 32 34 37 39 37 32 26 23 22 18 14 CLD OV OV OV OV OV OV OV SC FW CL CL FW BK OV OV OV BK FW CL FW SC WDR 20 22 26 35 02 03 02 02 34 19 20 18 18 18 18 23 29 30 29 29 28 WSP 20 13 07 08 11 14 14 11 05 03 04 06 11 19 25 21 22 25 20 19 22 P06 0 12 9 1 0 1 29 68 8 2 0 P12 12 9 2 69 15 Q06 0 0 0 0 0 0 0 2 0 0 0 Q12 0 0 0 2 0 T06 0/ 4 1/ 0 1/ 0 0/ 0 0/ 0 0/ 0 5/ 3 13/13 0/ 0 0/ 8 T12 1/ 2 0/ 0 9/ 6 14/13 1/ 8 POZ 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 POS 0 0 0 0 0 2 0 6 6 9 9 0 16 8 0 4 4 47 60 67 42 TYP R R R R R R R R R R R R R R R R R R S S R SNW 0 0 CIG 7 7 7 7 6 6 6 8 8 8 8 8 8 6 6 6 7 8 8 8 8 VIS 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7 7 7 7 OBV N N N N N N N N N N N N N N N N N N N N N \"\"\" >>> len ( kjfk . data . forecast ) 21 >>> kjfk . data . forecast [ 0 ] . ceiling Code ( repr = '7' , value = '6600 - 12,000 feet' ) The parse and from_report methods can parse a report string if you want to override the normal fetching process.","title":"class avwx.Mav(icao: str)"},{"location":"gfs/mav/#async-async_updatetimeout-int-10-bool","text":"Async updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"async async_update(timeout: int = 10) -&gt; bool"},{"location":"gfs/mav/#data-avwxstructsmavdata-none","text":"MavData dataclass of parsed data values and units. Parsed on update()","title":"data: avwx.structs.MavData = None"},{"location":"gfs/mav/#from_reportreport-str-avwxmav","text":"Returns an updated report object based on an existing report","title":"from_report(report: str) -&gt; avwx.Mav"},{"location":"gfs/mav/#icao-str","text":"4-character ICAO station ident code the report was initialized with","title":"icao: str"},{"location":"gfs/mav/#issued-date-none","text":"UTC date object when the report was issued","title":"issued: date = None"},{"location":"gfs/mav/#last_updated-datetimedatetime-none","text":"UTC Datetime object when the report was last updated","title":"last_updated: datetime.datetime = None"},{"location":"gfs/mav/#parsereport-str-bool","text":"Updates report data by parsing a given report","title":"parse(report: str) -&gt; bool"},{"location":"gfs/mav/#raw-str-none","text":"The unparsed report string. Fetched on update()","title":"raw: str = None"},{"location":"gfs/mav/#service-avwxserviceservice","text":"Service object used to fetch the report string","title":"service: avwx.service.Service"},{"location":"gfs/mav/#source-str-none","text":"Source URL root used to pull the current report data","title":"source: str = None"},{"location":"gfs/mav/#station-avwxstation","text":"Provides basic station info","title":"station: avwx.Station"},{"location":"gfs/mav/#units-avwxstructsunits","text":"Units inferred from the station location and report contents","title":"units: avwx.structs.Units"},{"location":"gfs/mav/#updatetimeout-int-10-bool","text":"Updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"update(timeout: int = 10) -&gt; bool"},{"location":"gfs/mav/#class-avwxstructsmavdata","text":"forecast : List[avwx.structs.MavPeriod] raw : str station : str time : avwx.structs.Timestamp","title":"class avwx.structs.MavData"},{"location":"gfs/mav/#class-avwxstructsmavperiod","text":"ceiling : avwx.structs.Code cloud : avwx.structs.Code dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number precip_amount_6 : avwx.structs.Code precip_amount_12 : avwx.structs.Code precip_chance_6 : avwx.structs.Number precip_chance_12 : avwx.structs.Number precip_type : avwx.structs.Code severe_storm_6 : avwx.structs.Number severe_storm_12 : avwx.structs.Number snow : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_6 : avwx.structs.Number thunderstorm_12 : avwx.structs.Number time : avwx.structs.Timestamp vis_obstruction : avwx.structs.Code visibility : avwx.structs.Code wind_direction : avwx.structs.Number wind_speed : avwx.structs.Number","title":"class avwx.structs.MavPeriod"},{"location":"gfs/mex/","text":"GFS MOS MEX The MEX report is an extended-range forecast (24-192 hours) based on the Global Forecast System model output and is only valid for ICAO stations in the United States, Puerto Rico, and US Virgin Islands. Reports are published at 0000 and 1200 UTC. class avwx. Mex ( icao: str ) The Mex class offers an object-oriented approach to managing MOS MEX data for a single station. Below is typical usage for fetching and pulling MAV data for KJFK. >>> from avwx import Mex >>> kjfk = Mex ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 4 , 20 , 12 , 7 , 7 , 393270 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK GFSX MOS GUIDANCE 4/20/2020 0000 UTC FHR 24| 36 48| 60 72| 84 96|108 120|132 144|156 168|180 192 MON 20| TUE 21| WED 22| THU 23| FRI 24| SAT 25| SUN 26| MON 27 CLIMO X/N 57| 45 59| 37 56| 40 52| 49 58| 46 59| 48 59| 44 58 45 63 TMP 50| 49 48| 41 49| 45 48| 52 51| 50 53| 51 52| 48 51 DPT 31| 39 26| 17 17| 24 40| 46 43| 40 44| 43 40| 35 31 CLD OV| OV OV| CL CL| OV OV| OV OV| PC OV| OV OV| OV OV WND 13| 14 26| 26 21| 16 13| 18 15| 16 12| 15 19| 19 11 P12 9| 1 73| 7 0| 9 43| 73 63| 27 51| 64 37| 35 32 24 23 P24 | 73| 7| 43| 77| 61| 73| 44 36 Q12 0| 0 2| 0 0| 0 1| 5 3| 0 2| 5 | Q24 | 1| 0| 0| 5| 2| | T12 1| 0 12| 1 0| 4 4| 8 11| 3 3| 14 7| 5 9 T24 | 1 | 14 | 4 | 12 | 11 | 14 | 11 PZP 0| 0 1| 0 2| 4 1| 0 0| 0 0| 0 0| 0 0 PSN 0| 0 0| 37 25| 15 4| 0 0| 0 0| 2 0| 3 5 PRS 0| 2 1| 32 28| 19 4| 0 1| 1 1| 1 1| 8 9 TYP R| R R| RS RS| R R| R R| R R| R R| R R SNW | 0| 0| 0| 0| 0| | \"\"\" >>> len ( kjfk . data . forecast ) 15 >>> kjfk . data . forecast [ 2 ] . precip_chance_24 Number ( repr = '73' , value = 73 , spoken = 'seven three' ) The parse and from_report methods can parse a report string if you want to override the normal fetching process. async async_update ( timeout: int = 10 ) -> bool Async updates report data by fetching and parsing the report Returns True if a new report is available, else False data : avwx.structs.MexData = None MavData dataclass of parsed data values and units. Parsed on update() from_report ( report: str ) -> avwx.Mex Returns an updated report object based on an existing report icao : str 4-character ICAO station ident code the report was initialized with issued : date = None UTC date object when the report was issued last_updated : datetime.datetime = None UTC Datetime object when the report was last updated parse ( report: str ) -> bool Updates report data by parsing a given report raw : str = None The unparsed report string. Fetched on update() service : avwx.service.Service Service object used to fetch the report string source : str = None Source URL root used to pull the current report data station : avwx.Station Provides basic station info units : avwx.structs.Units Units inferred from the station location and report contents update ( timeout: int = 10 ) -> bool Updates report data by fetching and parsing the report Returns True if a new report is available, else False class avwx.structs. MexData forecast : List[avwx.structs.MexPeriod] raw : str station : str time : avwx.structs.Timestamp class avwx.structs. MexPeriod cloud : avwx.structs.Code dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number precip_amount_12 : avwx.structs.Code precip_amount_24 : avwx.structs.Code precip_chance_12 : avwx.structs.Number precip_chance_24 : avwx.structs.Number precip_type : avwx.structs.Code rain_snow_mix : avwx.structs.Number severe_storm_12 : avwx.structs.Number severe_storm_24 : avwx.structs.Number snow_amount_24 : avwx.structs.Code snow : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_12 : avwx.structs.Number thunderstorm_24 : avwx.structs.Number time : avwx.structs.Timestamp","title":"GFS MOS MEX"},{"location":"gfs/mex/#gfs-mos-mex","text":"The MEX report is an extended-range forecast (24-192 hours) based on the Global Forecast System model output and is only valid for ICAO stations in the United States, Puerto Rico, and US Virgin Islands. Reports are published at 0000 and 1200 UTC.","title":"GFS MOS MEX"},{"location":"gfs/mex/#class-avwxmexicao-str","text":"The Mex class offers an object-oriented approach to managing MOS MEX data for a single station. Below is typical usage for fetching and pulling MAV data for KJFK. >>> from avwx import Mex >>> kjfk = Mex ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 4 , 20 , 12 , 7 , 7 , 393270 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK GFSX MOS GUIDANCE 4/20/2020 0000 UTC FHR 24| 36 48| 60 72| 84 96|108 120|132 144|156 168|180 192 MON 20| TUE 21| WED 22| THU 23| FRI 24| SAT 25| SUN 26| MON 27 CLIMO X/N 57| 45 59| 37 56| 40 52| 49 58| 46 59| 48 59| 44 58 45 63 TMP 50| 49 48| 41 49| 45 48| 52 51| 50 53| 51 52| 48 51 DPT 31| 39 26| 17 17| 24 40| 46 43| 40 44| 43 40| 35 31 CLD OV| OV OV| CL CL| OV OV| OV OV| PC OV| OV OV| OV OV WND 13| 14 26| 26 21| 16 13| 18 15| 16 12| 15 19| 19 11 P12 9| 1 73| 7 0| 9 43| 73 63| 27 51| 64 37| 35 32 24 23 P24 | 73| 7| 43| 77| 61| 73| 44 36 Q12 0| 0 2| 0 0| 0 1| 5 3| 0 2| 5 | Q24 | 1| 0| 0| 5| 2| | T12 1| 0 12| 1 0| 4 4| 8 11| 3 3| 14 7| 5 9 T24 | 1 | 14 | 4 | 12 | 11 | 14 | 11 PZP 0| 0 1| 0 2| 4 1| 0 0| 0 0| 0 0| 0 0 PSN 0| 0 0| 37 25| 15 4| 0 0| 0 0| 2 0| 3 5 PRS 0| 2 1| 32 28| 19 4| 0 1| 1 1| 1 1| 8 9 TYP R| R R| RS RS| R R| R R| R R| R R| R R SNW | 0| 0| 0| 0| 0| | \"\"\" >>> len ( kjfk . data . forecast ) 15 >>> kjfk . data . forecast [ 2 ] . precip_chance_24 Number ( repr = '73' , value = 73 , spoken = 'seven three' ) The parse and from_report methods can parse a report string if you want to override the normal fetching process.","title":"class avwx.Mex(icao: str)"},{"location":"gfs/mex/#async-async_updatetimeout-int-10-bool","text":"Async updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"async async_update(timeout: int = 10) -&gt; bool"},{"location":"gfs/mex/#data-avwxstructsmexdata-none","text":"MavData dataclass of parsed data values and units. Parsed on update()","title":"data: avwx.structs.MexData = None"},{"location":"gfs/mex/#from_reportreport-str-avwxmex","text":"Returns an updated report object based on an existing report","title":"from_report(report: str) -&gt; avwx.Mex"},{"location":"gfs/mex/#icao-str","text":"4-character ICAO station ident code the report was initialized with","title":"icao: str"},{"location":"gfs/mex/#issued-date-none","text":"UTC date object when the report was issued","title":"issued: date = None"},{"location":"gfs/mex/#last_updated-datetimedatetime-none","text":"UTC Datetime object when the report was last updated","title":"last_updated: datetime.datetime = None"},{"location":"gfs/mex/#parsereport-str-bool","text":"Updates report data by parsing a given report","title":"parse(report: str) -&gt; bool"},{"location":"gfs/mex/#raw-str-none","text":"The unparsed report string. Fetched on update()","title":"raw: str = None"},{"location":"gfs/mex/#service-avwxserviceservice","text":"Service object used to fetch the report string","title":"service: avwx.service.Service"},{"location":"gfs/mex/#source-str-none","text":"Source URL root used to pull the current report data","title":"source: str = None"},{"location":"gfs/mex/#station-avwxstation","text":"Provides basic station info","title":"station: avwx.Station"},{"location":"gfs/mex/#units-avwxstructsunits","text":"Units inferred from the station location and report contents","title":"units: avwx.structs.Units"},{"location":"gfs/mex/#updatetimeout-int-10-bool","text":"Updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"update(timeout: int = 10) -&gt; bool"},{"location":"gfs/mex/#class-avwxstructsmexdata","text":"forecast : List[avwx.structs.MexPeriod] raw : str station : str time : avwx.structs.Timestamp","title":"class avwx.structs.MexData"},{"location":"gfs/mex/#class-avwxstructsmexperiod","text":"cloud : avwx.structs.Code dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number precip_amount_12 : avwx.structs.Code precip_amount_24 : avwx.structs.Code precip_chance_12 : avwx.structs.Number precip_chance_24 : avwx.structs.Number precip_type : avwx.structs.Code rain_snow_mix : avwx.structs.Number severe_storm_12 : avwx.structs.Number severe_storm_24 : avwx.structs.Number snow_amount_24 : avwx.structs.Code snow : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_12 : avwx.structs.Number thunderstorm_24 : avwx.structs.Number time : avwx.structs.Timestamp","title":"class avwx.structs.MexPeriod"},{"location":"nbm/nbe/","text":"NBM NBE The NBE report is an extended-range forecast (24-192 hours) based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 12-hour increments and published near the top of every hour. class avwx. Nbe ( icao: str ) Class to handle NBM NBE report data Below is typical usage for fetching and pulling NBE data for KJFK. >>> from avwx import Nbe >>> kjfk = Nbe ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 7 , 28 , 1 , 23 , 4 , 909939 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK NBM V3.2 NBE GUIDANCE 7/28/2020 0000 UTC WED 29| THU 30| FRI 31| SAT 01| SUN 02| MON 03| TUE 04|WED CLIMO UTC 00 12| 00 12| 00 12| 00 12| 00 12| 00 12| 00 12| 00 FHR 24 36| 48 60| 72 84| 96 108|120 132|144 156|168 180|192 X/N 93 76| 91 76| 90 74| 86 72| 87 73| 85 74| 86 72| 84 68 83 TMP 84 80| 83 80| 81 78| 78 76| 78 78| 78 78| 78 76| 76 DPT 72 69| 68 69| 71 68| 67 66| 68 69| 70 71| 70 68| 69 SKY 61 21| 23 47| 80 73| 47 31| 30 54| 68 65| 66 59| 32 WDR 25 35| 20 26| 20 2| 16 1| 16 7| 16 24| 22 34| 18 WSP 5 2| 6 3| 5 4| 3 5| 7 4| 6 4| 5 4| 4 GST 11 4| 13 6| 13 10| 9 10| 13 7| 13 9| 16 9| 12 P12 48 23| 8 1| 23 28| 28 16| 18 17| 30 41| 46 31| 32 19 18 Q12 10 0| 0 0| 0 0| 0 0| 0 0| 0 64| 77 81| 83 Q24 | 0 | 0 | 0 | 0 | 0 |141 |164 DUR 2 1| 0 0| 0 0| 0 0| 0 0| 2 12| 12 12| 12 T12 46 32| 6 8| 21 22| 17 5| 6 5| 25 23| 19 18| 18 PZR 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 PSN 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 PPL 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 PRA 100 100|100 100|100 100|100 100|100 100|100 100|100 100|100 S12 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 SLV 138 114|111 119|119 121|113 101|108 117|134 132|124 123|121 I12 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 S24 | 0 | 0 | 0 | 0 | 0 | 0 | 0 SOL 100 320|190 230|270 250|360 290|370 30|190 260|250 230|450 \"\"\" >>> len ( kjfk . data . forecast ) 25 >>> kjfk . data . forecast [ 0 ] . wind_direction Number ( repr = '25' , value = 250 , spoken = 'two five zero' ) >>> print ( kjfk . data . forecast [ 1 ] . precip_duration . value , kjfk . units . duration ) 1 hour The parse and from_report methods can parse a report string if you want to override the normal fetching process. async async_update ( timeout: int = 10 ) -> bool Async updates report data by fetching and parsing the report Returns True if a new report is available, else False data : avwx.structs.NbeData = None NbeData dataclass of parsed data values and units. Parsed on update() from_report ( report: str ) -> avwx.Nbe Returns an updated report object based on an existing report icao : str 4-character ICAO station ident code the report was initialized with issued : date = None UTC date object when the report was issued last_updated : datetime.datetime = None UTC Datetime object when the report was last updated parse ( report: str ) -> bool Updates report data by parsing a given report raw : str = None The unparsed report string. Fetched on update() service : avwx.service.Service Service object used to fetch the report string source : str = None Source URL root used to pull the current report data station : avwx.Station Provides basic station info units : avwx.structs.Units Units inferred from the station location and report contents update ( timeout: int = 10 ) -> bool Updates report data by fetching and parsing the report Returns True if a new report is available, else False class avwx.structs. NbeData forecast : List[avwx.structs.NbePeriod] raw : str station : str time : avwx.structs.Timestamp class avwx.structs. NbePeriod dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number icing_amount_12 : avwx.structs.Number precip_amount_12 : avwx.structs.Number precip_amount_24 : avwx.structs.Number precip_chance_12 : avwx.structs.Number precip_duration : avwx.structs.Number rain : avwx.structs.Number sky_cover : avwx.structs.Number sleet : avwx.structs.Number snow_amount_12 : avwx.structs.Number snow_amount_24 : avwx.structs.Number snow_level : avwx.structs.Number snow : avwx.structs.Number solar_radiation : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_12 : avwx.structs.Number time : avwx.structs.Timestamp wave_height : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_speed : avwx.structs.Number","title":"NBM NBE"},{"location":"nbm/nbe/#nbm-nbe","text":"The NBE report is an extended-range forecast (24-192 hours) based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 12-hour increments and published near the top of every hour.","title":"NBM NBE"},{"location":"nbm/nbe/#class-avwxnbeicao-str","text":"Class to handle NBM NBE report data Below is typical usage for fetching and pulling NBE data for KJFK. >>> from avwx import Nbe >>> kjfk = Nbe ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 7 , 28 , 1 , 23 , 4 , 909939 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK NBM V3.2 NBE GUIDANCE 7/28/2020 0000 UTC WED 29| THU 30| FRI 31| SAT 01| SUN 02| MON 03| TUE 04|WED CLIMO UTC 00 12| 00 12| 00 12| 00 12| 00 12| 00 12| 00 12| 00 FHR 24 36| 48 60| 72 84| 96 108|120 132|144 156|168 180|192 X/N 93 76| 91 76| 90 74| 86 72| 87 73| 85 74| 86 72| 84 68 83 TMP 84 80| 83 80| 81 78| 78 76| 78 78| 78 78| 78 76| 76 DPT 72 69| 68 69| 71 68| 67 66| 68 69| 70 71| 70 68| 69 SKY 61 21| 23 47| 80 73| 47 31| 30 54| 68 65| 66 59| 32 WDR 25 35| 20 26| 20 2| 16 1| 16 7| 16 24| 22 34| 18 WSP 5 2| 6 3| 5 4| 3 5| 7 4| 6 4| 5 4| 4 GST 11 4| 13 6| 13 10| 9 10| 13 7| 13 9| 16 9| 12 P12 48 23| 8 1| 23 28| 28 16| 18 17| 30 41| 46 31| 32 19 18 Q12 10 0| 0 0| 0 0| 0 0| 0 0| 0 64| 77 81| 83 Q24 | 0 | 0 | 0 | 0 | 0 |141 |164 DUR 2 1| 0 0| 0 0| 0 0| 0 0| 2 12| 12 12| 12 T12 46 32| 6 8| 21 22| 17 5| 6 5| 25 23| 19 18| 18 PZR 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 PSN 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 PPL 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 PRA 100 100|100 100|100 100|100 100|100 100|100 100|100 100|100 S12 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 SLV 138 114|111 119|119 121|113 101|108 117|134 132|124 123|121 I12 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 0| 0 S24 | 0 | 0 | 0 | 0 | 0 | 0 | 0 SOL 100 320|190 230|270 250|360 290|370 30|190 260|250 230|450 \"\"\" >>> len ( kjfk . data . forecast ) 25 >>> kjfk . data . forecast [ 0 ] . wind_direction Number ( repr = '25' , value = 250 , spoken = 'two five zero' ) >>> print ( kjfk . data . forecast [ 1 ] . precip_duration . value , kjfk . units . duration ) 1 hour The parse and from_report methods can parse a report string if you want to override the normal fetching process.","title":"class avwx.Nbe(icao: str)"},{"location":"nbm/nbe/#async-async_updatetimeout-int-10-bool","text":"Async updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"async async_update(timeout: int = 10) -&gt; bool"},{"location":"nbm/nbe/#data-avwxstructsnbedata-none","text":"NbeData dataclass of parsed data values and units. Parsed on update()","title":"data: avwx.structs.NbeData = None"},{"location":"nbm/nbe/#from_reportreport-str-avwxnbe","text":"Returns an updated report object based on an existing report","title":"from_report(report: str) -&gt; avwx.Nbe"},{"location":"nbm/nbe/#icao-str","text":"4-character ICAO station ident code the report was initialized with","title":"icao: str"},{"location":"nbm/nbe/#issued-date-none","text":"UTC date object when the report was issued","title":"issued: date = None"},{"location":"nbm/nbe/#last_updated-datetimedatetime-none","text":"UTC Datetime object when the report was last updated","title":"last_updated: datetime.datetime = None"},{"location":"nbm/nbe/#parsereport-str-bool","text":"Updates report data by parsing a given report","title":"parse(report: str) -&gt; bool"},{"location":"nbm/nbe/#raw-str-none","text":"The unparsed report string. Fetched on update()","title":"raw: str = None"},{"location":"nbm/nbe/#service-avwxserviceservice","text":"Service object used to fetch the report string","title":"service: avwx.service.Service"},{"location":"nbm/nbe/#source-str-none","text":"Source URL root used to pull the current report data","title":"source: str = None"},{"location":"nbm/nbe/#station-avwxstation","text":"Provides basic station info","title":"station: avwx.Station"},{"location":"nbm/nbe/#units-avwxstructsunits","text":"Units inferred from the station location and report contents","title":"units: avwx.structs.Units"},{"location":"nbm/nbe/#updatetimeout-int-10-bool","text":"Updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"update(timeout: int = 10) -&gt; bool"},{"location":"nbm/nbe/#class-avwxstructsnbedata","text":"forecast : List[avwx.structs.NbePeriod] raw : str station : str time : avwx.structs.Timestamp","title":"class avwx.structs.NbeData"},{"location":"nbm/nbe/#class-avwxstructsnbeperiod","text":"dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number icing_amount_12 : avwx.structs.Number precip_amount_12 : avwx.structs.Number precip_amount_24 : avwx.structs.Number precip_chance_12 : avwx.structs.Number precip_duration : avwx.structs.Number rain : avwx.structs.Number sky_cover : avwx.structs.Number sleet : avwx.structs.Number snow_amount_12 : avwx.structs.Number snow_amount_24 : avwx.structs.Number snow_level : avwx.structs.Number snow : avwx.structs.Number solar_radiation : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_12 : avwx.structs.Number time : avwx.structs.Timestamp wave_height : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_speed : avwx.structs.Number","title":"class avwx.structs.NbePeriod"},{"location":"nbm/nbh/","text":"NBM NBH The NBH report is a 25-hour forecast based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 1-hour increments and are published near the top of every hour. class avwx. Nbh ( icao: str ) Class to handle NBM NBH report data Below is typical usage for fetching and pulling NBH data for KJFK. >>> from avwx import Nbh >>> kjfk = Nbh ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 7 , 26 , 20 , 37 , 42 , 352220 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK NBM V3.2 NBH GUIDANCE 7/26/2020 1900 UTC UTC 20 21 22 23 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 TMP 90 89 88 87 85 84 82 81 81 80 79 78 77 76 76 78 81 84 87 89 90 91 92 92 93 DPT 69 68 66 66 65 65 65 66 66 66 66 67 67 66 67 67 67 67 67 68 67 67 67 67 67 SKY 9 14 41 58 61 71 66 55 39 37 39 43 40 38 29 21 19 26 24 27 22 14 22 26 26 WDR 22 22 23 24 25 25 25 25 25 25 25 26 26 26 26 26 26 26 25 24 24 23 23 22 23 WSP 10 9 9 8 7 6 5 5 5 6 5 5 5 5 4 4 5 5 7 8 8 9 10 10 10 GST 17 16 16 15 14 12 11 12 12 12 12 11 11 9 9 9 9 10 11 13 14 15 16 17 17 P01 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 P06 0 0 0 Q01 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 DUR 0 T01 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PZR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PSN 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PPL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PRA 100100100100100100100100100100100100100100100100100100100100100100100100100 S01 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 SLV 99101102103105105105106105104106104104104104103102100 99 98 98 99100101102 I01 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 CIG 888888888360360350340888888888888888888888888888888888888888888888888888888 VIS 110120120140140130120120120120110110110110110120130140150150150150150150150 LCB 80 60999999999999999999999999999999999999999999999999999999999999999999999 MHT 26 26 20 19 8 7 6 4 4 5 5 5 6 4 5 6 6 11 20 27 37 39 43 39 31 TWD 24 26 26 27 26 26 24 23 24 26 26 26 27 27 28 27 27 27 27 26 26 26 25 25 24 TWS 15 14 14 13 11 11 11 10 11 11 10 11 10 8 8 7 8 9 12 13 14 15 17 17 16 HID 6 5 6 SOL 710500430250110 0 30 0 0 0 0 0 0 0 30160330500650760830870870850720 \"\"\" >>> len ( kjfk . data . forecast ) 25 >>> kjfk . data . forecast [ 0 ] . snow_level Number ( repr = '99' , value = 9900 , spoken = 'nine nine hundred' ) >>> print ( kjfk . data . forecast [ 0 ] . solar_radiation . value , kjfk . units . solar_radiation ) 710 W / m2 The parse and from_report methods can parse a report string if you want to override the normal fetching process. async async_update ( timeout: int = 10 ) -> bool Async updates report data by fetching and parsing the report Returns True if a new report is available, else False data : avwx.structs.NbhData = None NbhData dataclass of parsed data values and units. Parsed on update() from_report ( report: str ) -> avwx.Nbh Returns an updated report object based on an existing report icao : str 4-character ICAO station ident code the report was initialized with issued : date = None UTC date object when the report was issued last_updated : datetime.datetime = None UTC Datetime object when the report was last updated parse ( report: str ) -> bool Updates report data by parsing a given report raw : str = None The unparsed report string. Fetched on update() service : avwx.service.Service Service object used to fetch the report string source : str = None Source URL root used to pull the current report data station : avwx.Station Provides basic station info units : avwx.structs.Units Units inferred from the station location and report contents update ( timeout: int = 10 ) -> bool Updates report data by fetching and parsing the report Returns True if a new report is available, else False class avwx.structs. NbhData forecast : List[avwx.structs.NbhPeriod] raw : str station : str time : avwx.structs.Timestamp class avwx.structs. NbhPeriod ceiling : avwx.structs.Number cloud_base : avwx.structs.Number dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number haines : List[avwx.structs.Number] icing_amount_1 : avwx.structs.Number mixing_height : avwx.structs.Number precip_amount_1 : avwx.structs.Number precip_chance_1 : avwx.structs.Number precip_chance_6 : avwx.structs.Number precip_duration : avwx.structs.Number rain : avwx.structs.Number sky_cover : avwx.structs.Number sleet : avwx.structs.Number snow_amount_1 : avwx.structs.Number snow_level : avwx.structs.Number snow : avwx.structs.Number solar_radiation : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_1 : avwx.structs.Number time : avwx.structs.Timestamp transport_wind_direction : avwx.structs.Number transport_wind_speed : avwx.structs.Number visibility : avwx.structs.Number wave_height : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_speed : avwx.structs.Number","title":"NBM NBH"},{"location":"nbm/nbh/#nbm-nbh","text":"The NBH report is a 25-hour forecast based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 1-hour increments and are published near the top of every hour.","title":"NBM NBH"},{"location":"nbm/nbh/#class-avwxnbhicao-str","text":"Class to handle NBM NBH report data Below is typical usage for fetching and pulling NBH data for KJFK. >>> from avwx import Nbh >>> kjfk = Nbh ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 7 , 26 , 20 , 37 , 42 , 352220 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK NBM V3.2 NBH GUIDANCE 7/26/2020 1900 UTC UTC 20 21 22 23 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 TMP 90 89 88 87 85 84 82 81 81 80 79 78 77 76 76 78 81 84 87 89 90 91 92 92 93 DPT 69 68 66 66 65 65 65 66 66 66 66 67 67 66 67 67 67 67 67 68 67 67 67 67 67 SKY 9 14 41 58 61 71 66 55 39 37 39 43 40 38 29 21 19 26 24 27 22 14 22 26 26 WDR 22 22 23 24 25 25 25 25 25 25 25 26 26 26 26 26 26 26 25 24 24 23 23 22 23 WSP 10 9 9 8 7 6 5 5 5 6 5 5 5 5 4 4 5 5 7 8 8 9 10 10 10 GST 17 16 16 15 14 12 11 12 12 12 12 11 11 9 9 9 9 10 11 13 14 15 16 17 17 P01 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 P06 0 0 0 Q01 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 DUR 0 T01 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PZR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PSN 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PPL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PRA 100100100100100100100100100100100100100100100100100100100100100100100100100 S01 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 SLV 99101102103105105105106105104106104104104104103102100 99 98 98 99100101102 I01 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 CIG 888888888360360350340888888888888888888888888888888888888888888888888888888 VIS 110120120140140130120120120120110110110110110120130140150150150150150150150 LCB 80 60999999999999999999999999999999999999999999999999999999999999999999999 MHT 26 26 20 19 8 7 6 4 4 5 5 5 6 4 5 6 6 11 20 27 37 39 43 39 31 TWD 24 26 26 27 26 26 24 23 24 26 26 26 27 27 28 27 27 27 27 26 26 26 25 25 24 TWS 15 14 14 13 11 11 11 10 11 11 10 11 10 8 8 7 8 9 12 13 14 15 17 17 16 HID 6 5 6 SOL 710500430250110 0 30 0 0 0 0 0 0 0 30160330500650760830870870850720 \"\"\" >>> len ( kjfk . data . forecast ) 25 >>> kjfk . data . forecast [ 0 ] . snow_level Number ( repr = '99' , value = 9900 , spoken = 'nine nine hundred' ) >>> print ( kjfk . data . forecast [ 0 ] . solar_radiation . value , kjfk . units . solar_radiation ) 710 W / m2 The parse and from_report methods can parse a report string if you want to override the normal fetching process.","title":"class avwx.Nbh(icao: str)"},{"location":"nbm/nbh/#async-async_updatetimeout-int-10-bool","text":"Async updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"async async_update(timeout: int = 10) -&gt; bool"},{"location":"nbm/nbh/#data-avwxstructsnbhdata-none","text":"NbhData dataclass of parsed data values and units. Parsed on update()","title":"data: avwx.structs.NbhData = None"},{"location":"nbm/nbh/#from_reportreport-str-avwxnbh","text":"Returns an updated report object based on an existing report","title":"from_report(report: str) -&gt; avwx.Nbh"},{"location":"nbm/nbh/#icao-str","text":"4-character ICAO station ident code the report was initialized with","title":"icao: str"},{"location":"nbm/nbh/#issued-date-none","text":"UTC date object when the report was issued","title":"issued: date = None"},{"location":"nbm/nbh/#last_updated-datetimedatetime-none","text":"UTC Datetime object when the report was last updated","title":"last_updated: datetime.datetime = None"},{"location":"nbm/nbh/#parsereport-str-bool","text":"Updates report data by parsing a given report","title":"parse(report: str) -&gt; bool"},{"location":"nbm/nbh/#raw-str-none","text":"The unparsed report string. Fetched on update()","title":"raw: str = None"},{"location":"nbm/nbh/#service-avwxserviceservice","text":"Service object used to fetch the report string","title":"service: avwx.service.Service"},{"location":"nbm/nbh/#source-str-none","text":"Source URL root used to pull the current report data","title":"source: str = None"},{"location":"nbm/nbh/#station-avwxstation","text":"Provides basic station info","title":"station: avwx.Station"},{"location":"nbm/nbh/#units-avwxstructsunits","text":"Units inferred from the station location and report contents","title":"units: avwx.structs.Units"},{"location":"nbm/nbh/#updatetimeout-int-10-bool","text":"Updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"update(timeout: int = 10) -&gt; bool"},{"location":"nbm/nbh/#class-avwxstructsnbhdata","text":"forecast : List[avwx.structs.NbhPeriod] raw : str station : str time : avwx.structs.Timestamp","title":"class avwx.structs.NbhData"},{"location":"nbm/nbh/#class-avwxstructsnbhperiod","text":"ceiling : avwx.structs.Number cloud_base : avwx.structs.Number dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number haines : List[avwx.structs.Number] icing_amount_1 : avwx.structs.Number mixing_height : avwx.structs.Number precip_amount_1 : avwx.structs.Number precip_chance_1 : avwx.structs.Number precip_chance_6 : avwx.structs.Number precip_duration : avwx.structs.Number rain : avwx.structs.Number sky_cover : avwx.structs.Number sleet : avwx.structs.Number snow_amount_1 : avwx.structs.Number snow_level : avwx.structs.Number snow : avwx.structs.Number solar_radiation : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_1 : avwx.structs.Number time : avwx.structs.Timestamp transport_wind_direction : avwx.structs.Number transport_wind_speed : avwx.structs.Number visibility : avwx.structs.Number wave_height : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_speed : avwx.structs.Number","title":"class avwx.structs.NbhPeriod"},{"location":"nbm/nbs/","text":"NBM NBS The NBS report is a short-range forecast (6-72 hours) based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 3-hour increments and published near the top of every hour. class avwx. Nbs ( icao: str ) Class to handle NBM NBS report data Below is typical usage for fetching and pulling Nbs data for KJFK. >>> from avwx import Nbs >>> kjfk = Nbs ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 7 , 28 , 1 , 3 , 46 , 447635 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK NBM V3.2 NBS GUIDANCE 7/27/2020 2300 UTC DT /JULY 28 /JULY 29 /JULY 30 UTC 03 06 09 12 15 18 21 00 03 06 09 12 15 18 21 00 03 06 09 12 15 18 21 FHR 04 07 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 64 67 70 N/X 79 93 76 91 76 TMP 85 82 80 83 89 91 89 84 81 79 77 80 85 89 87 83 81 79 77 80 86 88 86 DPT 70 70 71 72 72 72 73 72 72 71 69 69 68 67 68 69 68 67 68 69 68 69 70 SKY 4 10 2 4 12 23 38 61 53 62 51 26 19 9 21 24 25 34 32 45 57 70 79 WDR 23 24 23 24 24 22 23 27 28 28 34 35 21 20 19 22 23 25 26 26 23 20 20 WSP 8 8 5 6 8 9 7 5 3 2 1 2 3 6 9 7 4 4 3 3 4 7 8 GST 16 15 11 11 13 15 15 11 9 5 4 4 6 12 15 13 11 11 8 6 7 13 15 P06 0 1 15 48 17 11 8 8 1 0 5 P12 1 48 17 8 1 Q06 0 0 0 11 0 0 0 0 0 0 0 Q12 0 11 0 0 0 DUR 0 2 0 0 0 T03 2 3 1 1 2 10 27 30 21 13 8 5 1 0 2 3 4 3 2 3 1 3 7 T12 4 48 33 6 8 PZR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PSN 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PPL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PRA 100100100100100100100100100100100100100100100100100100100100100100100 S06 0 0 0 0 0 0 0 0 0 0 0 SLV 108112113133135139141139137134124113102 99107115114118118119118118118 I06 0 0 0 0 0 0 0 0 0 0 0 CIG 888888888888888888888170888150888888888888888888888888888888888888888 VIS 120120110120130130130110110110110130110110110120120120110110110110110 LCB 60 70999 90 90999 50 60 60 60 60 60 22999999200230 70 80 60 60150 60 MHT 7 6 5 13 30 46 19 15 7 7 10 16 40 35 13 4 4 4 9 18 31 27 13 TWD 23 24 23 27 25 24 27 27 28 21 34 6 26 23 20 19 26 23 27 29 24 20 18 TWS 17 16 9 11 13 16 12 9 5 5 4 3 4 8 11 10 8 10 10 6 6 9 13 HID 4 4 4 4 3 4 4 5 5 3 4 SOL 0 0 0320700760360100 0 0 0320720830620190 0 0 0230480570540 \"\"\" >>> len ( kjfk . data . forecast ) 23 >>> kjfk . data . forecast [ 0 ] . ceiling Number ( repr = '888' , value = None , spoken = 'unlimited' ) >>> print ( kjfk . data . forecast [ 7 ] . precip_amount_12 . value , kjfk . units . accumulation ) 0.11 in The parse and from_report methods can parse a report string if you want to override the normal fetching process. async async_update ( timeout: int = 10 ) -> bool Async updates report data by fetching and parsing the report Returns True if a new report is available, else False data : avwx.structs.NbsData = None NbsData dataclass of parsed data values and units. Parsed on update() from_report ( report: str ) -> avwx.Nbs Returns an updated report object based on an existing report icao : str 4-character ICAO station ident code the report was initialized with issued : date = None UTC date object when the report was issued last_updated : datetime.datetime = None UTC Datetime object when the report was last updated parse ( report: str ) -> bool Updates report data by parsing a given report raw : str = None The unparsed report string. Fetched on update() service : avwx.service.Service Service object used to fetch the report string source : str = None Source URL root used to pull the current report data station : avwx.Station Provides basic station info units : avwx.structs.Units Units inferred from the station location and report contents update ( timeout: int = 10 ) -> bool Updates report data by fetching and parsing the report Returns True if a new report is available, else False class avwx.structs. NbsData forecast : List[avwx.structs.NbsPeriod] raw : str station : str time : avwx.structs.Timestamp class avwx.structs. NbsPeriod ceiling : avwx.structs.Number cloud_base : avwx.structs.Number dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number haines : List[avwx.structs.Number] icing_amount_6 : avwx.structs.Number mixing_height : avwx.structs.Number precip_amount_12 : avwx.structs.Number precip_amount_6 : avwx.structs.Number precip_chance_12 : avwx.structs.Number precip_chance_6 : avwx.structs.Number precip_duration : avwx.structs.Number rain : avwx.structs.Number sky_cover : avwx.structs.Number sleet : avwx.structs.Number snow_amount_6 : avwx.structs.Number snow_level : avwx.structs.Number snow : avwx.structs.Number solar_radiation : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_12 : avwx.structs.Number thunderstorm_3 : avwx.structs.Number time : avwx.structs.Timestamp transport_wind_direction : avwx.structs.Number transport_wind_speed : avwx.structs.Number visibility : avwx.structs.Number wave_height : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_speed : avwx.structs.Number","title":"NBM NBS"},{"location":"nbm/nbs/#nbm-nbs","text":"The NBS report is a short-range forecast (6-72 hours) based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 3-hour increments and published near the top of every hour.","title":"NBM NBS"},{"location":"nbm/nbs/#class-avwxnbsicao-str","text":"Class to handle NBM NBS report data Below is typical usage for fetching and pulling Nbs data for KJFK. >>> from avwx import Nbs >>> kjfk = Nbs ( 'KJFK' ) >>> kjfk . station . name 'John F Kennedy International Airport' >>> kjfk . update () True >>> kjfk . last_updated datetime . datetime ( 2020 , 7 , 28 , 1 , 3 , 46 , 447635 , tzinfo = datetime . timezone . utc ) >>> print ( kjfk . raw ) \"\"\" KJFK NBM V3.2 NBS GUIDANCE 7/27/2020 2300 UTC DT /JULY 28 /JULY 29 /JULY 30 UTC 03 06 09 12 15 18 21 00 03 06 09 12 15 18 21 00 03 06 09 12 15 18 21 FHR 04 07 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 64 67 70 N/X 79 93 76 91 76 TMP 85 82 80 83 89 91 89 84 81 79 77 80 85 89 87 83 81 79 77 80 86 88 86 DPT 70 70 71 72 72 72 73 72 72 71 69 69 68 67 68 69 68 67 68 69 68 69 70 SKY 4 10 2 4 12 23 38 61 53 62 51 26 19 9 21 24 25 34 32 45 57 70 79 WDR 23 24 23 24 24 22 23 27 28 28 34 35 21 20 19 22 23 25 26 26 23 20 20 WSP 8 8 5 6 8 9 7 5 3 2 1 2 3 6 9 7 4 4 3 3 4 7 8 GST 16 15 11 11 13 15 15 11 9 5 4 4 6 12 15 13 11 11 8 6 7 13 15 P06 0 1 15 48 17 11 8 8 1 0 5 P12 1 48 17 8 1 Q06 0 0 0 11 0 0 0 0 0 0 0 Q12 0 11 0 0 0 DUR 0 2 0 0 0 T03 2 3 1 1 2 10 27 30 21 13 8 5 1 0 2 3 4 3 2 3 1 3 7 T12 4 48 33 6 8 PZR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PSN 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PPL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 PRA 100100100100100100100100100100100100100100100100100100100100100100100 S06 0 0 0 0 0 0 0 0 0 0 0 SLV 108112113133135139141139137134124113102 99107115114118118119118118118 I06 0 0 0 0 0 0 0 0 0 0 0 CIG 888888888888888888888170888150888888888888888888888888888888888888888 VIS 120120110120130130130110110110110130110110110120120120110110110110110 LCB 60 70999 90 90999 50 60 60 60 60 60 22999999200230 70 80 60 60150 60 MHT 7 6 5 13 30 46 19 15 7 7 10 16 40 35 13 4 4 4 9 18 31 27 13 TWD 23 24 23 27 25 24 27 27 28 21 34 6 26 23 20 19 26 23 27 29 24 20 18 TWS 17 16 9 11 13 16 12 9 5 5 4 3 4 8 11 10 8 10 10 6 6 9 13 HID 4 4 4 4 3 4 4 5 5 3 4 SOL 0 0 0320700760360100 0 0 0320720830620190 0 0 0230480570540 \"\"\" >>> len ( kjfk . data . forecast ) 23 >>> kjfk . data . forecast [ 0 ] . ceiling Number ( repr = '888' , value = None , spoken = 'unlimited' ) >>> print ( kjfk . data . forecast [ 7 ] . precip_amount_12 . value , kjfk . units . accumulation ) 0.11 in The parse and from_report methods can parse a report string if you want to override the normal fetching process.","title":"class avwx.Nbs(icao: str)"},{"location":"nbm/nbs/#async-async_updatetimeout-int-10-bool","text":"Async updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"async async_update(timeout: int = 10) -&gt; bool"},{"location":"nbm/nbs/#data-avwxstructsnbsdata-none","text":"NbsData dataclass of parsed data values and units. Parsed on update()","title":"data: avwx.structs.NbsData = None"},{"location":"nbm/nbs/#from_reportreport-str-avwxnbs","text":"Returns an updated report object based on an existing report","title":"from_report(report: str) -&gt; avwx.Nbs"},{"location":"nbm/nbs/#icao-str","text":"4-character ICAO station ident code the report was initialized with","title":"icao: str"},{"location":"nbm/nbs/#issued-date-none","text":"UTC date object when the report was issued","title":"issued: date = None"},{"location":"nbm/nbs/#last_updated-datetimedatetime-none","text":"UTC Datetime object when the report was last updated","title":"last_updated: datetime.datetime = None"},{"location":"nbm/nbs/#parsereport-str-bool","text":"Updates report data by parsing a given report","title":"parse(report: str) -&gt; bool"},{"location":"nbm/nbs/#raw-str-none","text":"The unparsed report string. Fetched on update()","title":"raw: str = None"},{"location":"nbm/nbs/#service-avwxserviceservice","text":"Service object used to fetch the report string","title":"service: avwx.service.Service"},{"location":"nbm/nbs/#source-str-none","text":"Source URL root used to pull the current report data","title":"source: str = None"},{"location":"nbm/nbs/#station-avwxstation","text":"Provides basic station info","title":"station: avwx.Station"},{"location":"nbm/nbs/#units-avwxstructsunits","text":"Units inferred from the station location and report contents","title":"units: avwx.structs.Units"},{"location":"nbm/nbs/#updatetimeout-int-10-bool","text":"Updates report data by fetching and parsing the report Returns True if a new report is available, else False","title":"update(timeout: int = 10) -&gt; bool"},{"location":"nbm/nbs/#class-avwxstructsnbsdata","text":"forecast : List[avwx.structs.NbsPeriod] raw : str station : str time : avwx.structs.Timestamp","title":"class avwx.structs.NbsData"},{"location":"nbm/nbs/#class-avwxstructsnbsperiod","text":"ceiling : avwx.structs.Number cloud_base : avwx.structs.Number dewpoint : avwx.structs.Number freezing_precip : avwx.structs.Number haines : List[avwx.structs.Number] icing_amount_6 : avwx.structs.Number mixing_height : avwx.structs.Number precip_amount_12 : avwx.structs.Number precip_amount_6 : avwx.structs.Number precip_chance_12 : avwx.structs.Number precip_chance_6 : avwx.structs.Number precip_duration : avwx.structs.Number rain : avwx.structs.Number sky_cover : avwx.structs.Number sleet : avwx.structs.Number snow_amount_6 : avwx.structs.Number snow_level : avwx.structs.Number snow : avwx.structs.Number solar_radiation : avwx.structs.Number temperature : avwx.structs.Number thunderstorm_12 : avwx.structs.Number thunderstorm_3 : avwx.structs.Number time : avwx.structs.Timestamp transport_wind_direction : avwx.structs.Number transport_wind_speed : avwx.structs.Number visibility : avwx.structs.Number wave_height : avwx.structs.Number wind_direction : avwx.structs.Number wind_gust : avwx.structs.Number wind_speed : avwx.structs.Number","title":"class avwx.structs.NbsPeriod"},{"location":"util/exceptions/","text":"Exceptions class avwx.exceptions. BadStation Station does not exist class avwx.exceptions. InvalidRequest Unable to fetch data class avwx.exceptions. SourceError Source servers returned an error code","title":"Exceptions"},{"location":"util/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"util/exceptions/#class-avwxexceptionsbadstation","text":"Station does not exist","title":"class avwx.exceptions.BadStation"},{"location":"util/exceptions/#class-avwxexceptionsinvalidrequest","text":"Unable to fetch data","title":"class avwx.exceptions.InvalidRequest"},{"location":"util/exceptions/#class-avwxexceptionssourceerror","text":"Source servers returned an error code","title":"class avwx.exceptions.SourceError"},{"location":"util/service/","text":"Report Source Services AVWX fetches the raw weather reports from third-party services via REST API calls or file downloads. We use Service objects to handle the request and extraction for us. Basic Module Use METARs and TAFs are the most widely-supported report types, so an effort has been made to localize some of these services to a regional source. The get_service function was introduced to determine the best service for a given station. avwx.service. get_service ( station: str, country: str ) -> avwx.service.Service Returns the preferred scrape service for a given station # Fetch Australian reports station = 'YWOL' country = 'AU' # can source from avwx.Station.country # Get the station's preferred service and initialize to fetch METARs service = avwx . service . get_service ( station , country )( 'metar' ) # service is now avwx.service.AUBOM init'd to fetch METARs # Fetch the current METAR report = service . fetch ( station ) Other report types require specific service classes which are detailed below. Base Service Class Both web scrape and file-based services are based off of the Service class and should all return the final report string with the fetch method. class avwx.service. Service ( report_type: str ) Base Service class for fetching reports fetch ( station: str, timeout: int = 10 ) -> str Fetches a report string from the service async async_fetch ( station: str, timeout: int = 10 ) -> str Asynchronously fetch a report string from the service Web Scrape Services These services request reports via HTML scraping or direct API requests. Requests are ephemeral and will call the selected service each time. class.service.scrape. ScrapeService ( report_type: str ) Service class for fetching reports via direct web requests Unless overwritten, this class accepts \"metar\" and \"taf\" as valid report types class avwx.service. NOAA ( report_type: str ) Requests data from NOAA class avwx.service. NOAA_ADDS ( report_type: str ) Requests data from NOAA ADDS This class accepts \"metar\" , \"taf\" , and \"aircraftreport\" as valid report types. It will also accept lat and lon as fetch parameters in addition to station . avwx.service. AMO ( report_type: str ) Requests data from AMO KMA for Korean stations avwx.service. MAC ( report_type: str ) Requests data from Meteorologia Aeronautica Civil for Columbian stations avwx.service. AUBOM ( report_type: str ) Requests data from the Australian Bureau of Meteorology File Services These services are directed at FTP servers to find the most recent file associated with the search criteria. Files are stored in a temporary directory which is deleted when the program ends. Fetch requests will extract reports from the downloaded file until an update interval has been exceeded, at which point the service will check for a newer file. avwx.service.files.FileService( report_type ) Service class for fetching reports via managed source files is_outdated : bool last_updated : Optional[datetime.datetime] update_interval : datetime.timedelta = datetime.timedelta(minutes=10) async update ( wait: bool = False, timeout: int = 10 ) -> bool Update the stored file and returns success If wait, this will block if the file is already being updated fetch ( station: str, wait: bool = True, timeout: int = 10, force: bool = False ) -> Optional[str] Fetch a report string from the source file If wait, this will block if the file is already being updated Can force the service to fetch a new file async async_fetch ( station: str, wait: bool = True, timeout: int = 10, force: bool = False ) -> Optional[str] Asynchronously fetch a report string from the source file If wait, this will block if the file is already being updated Can force the service to fetch a new file avwx.service.NOAA_NBM( report_type ) Requests forecast data from NOAA NBM FTP servers This class accepts \"nbh\" , \"nbs\" , and \"nbe\" as valid report types avwx.service.NOAA_GFS( report_type ) Requests forecast data from NOAA GFS FTP servers This class accepts \"mav\" and \"mex\" as valid report types Adding a New Service If the existing services are not supplying the report(s) you need, adding a new service is easy. First, you'll need to determine if your source can be scraped or you need to download a file. ScrapeService For web scraping sources, you'll need to do the following things: Add the base URL and method (if not \"GET\" ) Implement the ScrapeService._make_url to return the source URL and query parameters Implement the ScrapeService._extract function to return just the report string (starting at the station ID) from the response Let's look at the MAC service as an example: class MAC ( ScrapeService ): \"\"\" Requests data from Meteorologia Aeronautica Civil for Columbian stations \"\"\" url = \"http://meteorologia.aerocivil.gov.co/expert_text_query/parse\" method = \"POST\" def _make_url ( self , station : str ) -> ( str , dict ): \"\"\" Returns a formatted URL and parameters \"\"\" return self . url , { \"query\" : f \" { self . rtype } { station } \" } def _extract ( self , raw : str , station : str ) -> str : \"\"\" Extracts the reports message using string finding \"\"\" report = raw [ raw . find ( station . upper () + \" \" ) :] report = report [: report . find ( \" =\" )] return report Our URL and query parameters are returned using _make_url so fetch knows how to request the report. The result of this query is given to _extract which returns the report or list of reports. Once your service is created, it can optionally be added to avwx.service.scrape.PREFERRED if the service covers all stations with a known ICAO prefix or avwx.service.scrape.BY_COUNTRY if the service covers all stations in a single country. This is how avwx.service.get_service determines the preferred service. For example, the MAC service is preferred over NOAA for all ICAOs starting with \"SK\" while AUBOM is better for all Australian stations. FileService For web scraping sources, you'll need to do the following things: Add the base URL and valid report types Implement the FileService._urls to iterate through source URLs Implement the FileService._extract function to return just the report string (starting at the station ID) from the Let's look at the NOAA_NBM service as an example: class NOAA_NBM ( FileService ): \"\"\" Requests forecast data from NOAA NBM FTP servers \"\"\" url = \"https://nomads.ncep.noaa.gov/pub/data/nccf/com/blend/prod/blend. {} / {} /text/blend_ {} tx.t {} z\" _valid_types = ( \"nbh\" , \"nbs\" , \"nbe\" ) @property def _urls ( self ) -> Iterator [ str ]: \"\"\" Iterates through hourly updates no older than two days \"\"\" date = dt . datetime . now ( tz = dt . timezone . utc ) cutoff = date - dt . timedelta ( days = 1 ) while date > cutoff : timestamp = date . strftime ( r \"%Y%m %d \" ) hour = str ( date . hour ) . zfill ( 2 ) yield self . url . format ( timestamp , hour , self . report_type , hour ) date -= dt . timedelta ( hours = 1 ) def _extract ( self , station : str , source : TextIO ) -> Optional [ str ]: \"\"\" Returns report pulled from the saved file \"\"\" start = station + \" \" end = self . report_type . upper () + \" GUIDANCE\" txt = source . read () txt = txt [ txt . find ( start ) :] txt = txt [: txt . find ( end , 30 )] lines = [] for line in txt . split ( \" \\n \" ): if \"CLIMO\" not in line : line = line . strip () if not line : break lines . append ( line ) return \" \\n \" . join ( lines ) or None In this example, we iterate through _urls looking for the most recent published file. URL iterators should always have a lower bound to stop iteration so the service can return a null response. Once the file is downloaded, the requested station and file-like object are passed to the _extract method to find and return the report from the file. This method will not be called if the file doesn't exist.","title":"Data Services"},{"location":"util/service/#report-source-services","text":"AVWX fetches the raw weather reports from third-party services via REST API calls or file downloads. We use Service objects to handle the request and extraction for us.","title":"Report Source Services"},{"location":"util/service/#basic-module-use","text":"METARs and TAFs are the most widely-supported report types, so an effort has been made to localize some of these services to a regional source. The get_service function was introduced to determine the best service for a given station.","title":"Basic Module Use"},{"location":"util/service/#avwxserviceget_servicestation-str-country-str-avwxserviceservice","text":"Returns the preferred scrape service for a given station # Fetch Australian reports station = 'YWOL' country = 'AU' # can source from avwx.Station.country # Get the station's preferred service and initialize to fetch METARs service = avwx . service . get_service ( station , country )( 'metar' ) # service is now avwx.service.AUBOM init'd to fetch METARs # Fetch the current METAR report = service . fetch ( station ) Other report types require specific service classes which are detailed below.","title":"avwx.service.get_service(station: str, country: str) -&gt; avwx.service.Service"},{"location":"util/service/#base-service-class","text":"Both web scrape and file-based services are based off of the Service class and should all return the final report string with the fetch method.","title":"Base Service Class"},{"location":"util/service/#class-avwxserviceservicereport_type-str","text":"Base Service class for fetching reports","title":"class avwx.service.Service(report_type: str)"},{"location":"util/service/#fetchstation-str-timeout-int-10-str","text":"Fetches a report string from the service","title":"fetch(station: str, timeout: int = 10) -&gt; str"},{"location":"util/service/#async-async_fetchstation-str-timeout-int-10-str","text":"Asynchronously fetch a report string from the service","title":"async async_fetch(station: str, timeout: int = 10) -&gt; str"},{"location":"util/service/#web-scrape-services","text":"These services request reports via HTML scraping or direct API requests. Requests are ephemeral and will call the selected service each time.","title":"Web Scrape Services"},{"location":"util/service/#classservicescrapescrapeservicereport_type-str","text":"Service class for fetching reports via direct web requests Unless overwritten, this class accepts \"metar\" and \"taf\" as valid report types","title":"class.service.scrape.ScrapeService(report_type: str)"},{"location":"util/service/#class-avwxservicenoaareport_type-str","text":"Requests data from NOAA","title":"class avwx.service.NOAA(report_type: str)"},{"location":"util/service/#class-avwxservicenoaa_addsreport_type-str","text":"Requests data from NOAA ADDS This class accepts \"metar\" , \"taf\" , and \"aircraftreport\" as valid report types. It will also accept lat and lon as fetch parameters in addition to station .","title":"class avwx.service.NOAA_ADDS(report_type: str)"},{"location":"util/service/#avwxserviceamoreport_type-str","text":"Requests data from AMO KMA for Korean stations","title":"avwx.service.AMO(report_type: str)"},{"location":"util/service/#avwxservicemacreport_type-str","text":"Requests data from Meteorologia Aeronautica Civil for Columbian stations","title":"avwx.service.MAC(report_type: str)"},{"location":"util/service/#avwxserviceaubomreport_type-str","text":"Requests data from the Australian Bureau of Meteorology","title":"avwx.service.AUBOM(report_type: str)"},{"location":"util/service/#file-services","text":"These services are directed at FTP servers to find the most recent file associated with the search criteria. Files are stored in a temporary directory which is deleted when the program ends. Fetch requests will extract reports from the downloaded file until an update interval has been exceeded, at which point the service will check for a newer file.","title":"File Services"},{"location":"util/service/#avwxservicefilesfileservicereport_type","text":"Service class for fetching reports via managed source files","title":"avwx.service.files.FileService(report_type)"},{"location":"util/service/#is_outdated-bool","text":"","title":"is_outdated: bool"},{"location":"util/service/#last_updated-optionaldatetimedatetime","text":"","title":"last_updated: Optional[datetime.datetime]"},{"location":"util/service/#update_interval-datetimetimedelta-datetimetimedeltaminutes10","text":"","title":"update_interval: datetime.timedelta = datetime.timedelta(minutes=10)"},{"location":"util/service/#async-updatewait-bool-false-timeout-int-10-bool","text":"Update the stored file and returns success If wait, this will block if the file is already being updated","title":"async update(wait: bool = False, timeout: int = 10) -&gt; bool"},{"location":"util/service/#fetchstation-str-wait-bool-true-timeout-int-10-force-bool-false-optionalstr","text":"Fetch a report string from the source file If wait, this will block if the file is already being updated Can force the service to fetch a new file","title":"fetch(station: str, wait: bool = True, timeout: int = 10, force: bool = False) -&gt; Optional[str]"},{"location":"util/service/#async-async_fetchstation-str-wait-bool-true-timeout-int-10-force-bool-false-optionalstr","text":"Asynchronously fetch a report string from the source file If wait, this will block if the file is already being updated Can force the service to fetch a new file","title":"async async_fetch(station: str, wait: bool = True, timeout: int = 10, force: bool = False) -&gt; Optional[str]"},{"location":"util/service/#avwxservicenoaa_nbmreport_type","text":"Requests forecast data from NOAA NBM FTP servers This class accepts \"nbh\" , \"nbs\" , and \"nbe\" as valid report types","title":"avwx.service.NOAA_NBM(report_type)"},{"location":"util/service/#avwxservicenoaa_gfsreport_type","text":"Requests forecast data from NOAA GFS FTP servers This class accepts \"mav\" and \"mex\" as valid report types","title":"avwx.service.NOAA_GFS(report_type)"},{"location":"util/service/#adding-a-new-service","text":"If the existing services are not supplying the report(s) you need, adding a new service is easy. First, you'll need to determine if your source can be scraped or you need to download a file.","title":"Adding a New Service"},{"location":"util/service/#scrapeservice","text":"For web scraping sources, you'll need to do the following things: Add the base URL and method (if not \"GET\" ) Implement the ScrapeService._make_url to return the source URL and query parameters Implement the ScrapeService._extract function to return just the report string (starting at the station ID) from the response Let's look at the MAC service as an example: class MAC ( ScrapeService ): \"\"\" Requests data from Meteorologia Aeronautica Civil for Columbian stations \"\"\" url = \"http://meteorologia.aerocivil.gov.co/expert_text_query/parse\" method = \"POST\" def _make_url ( self , station : str ) -> ( str , dict ): \"\"\" Returns a formatted URL and parameters \"\"\" return self . url , { \"query\" : f \" { self . rtype } { station } \" } def _extract ( self , raw : str , station : str ) -> str : \"\"\" Extracts the reports message using string finding \"\"\" report = raw [ raw . find ( station . upper () + \" \" ) :] report = report [: report . find ( \" =\" )] return report Our URL and query parameters are returned using _make_url so fetch knows how to request the report. The result of this query is given to _extract which returns the report or list of reports. Once your service is created, it can optionally be added to avwx.service.scrape.PREFERRED if the service covers all stations with a known ICAO prefix or avwx.service.scrape.BY_COUNTRY if the service covers all stations in a single country. This is how avwx.service.get_service determines the preferred service. For example, the MAC service is preferred over NOAA for all ICAOs starting with \"SK\" while AUBOM is better for all Australian stations.","title":"ScrapeService"},{"location":"util/service/#fileservice","text":"For web scraping sources, you'll need to do the following things: Add the base URL and valid report types Implement the FileService._urls to iterate through source URLs Implement the FileService._extract function to return just the report string (starting at the station ID) from the Let's look at the NOAA_NBM service as an example: class NOAA_NBM ( FileService ): \"\"\" Requests forecast data from NOAA NBM FTP servers \"\"\" url = \"https://nomads.ncep.noaa.gov/pub/data/nccf/com/blend/prod/blend. {} / {} /text/blend_ {} tx.t {} z\" _valid_types = ( \"nbh\" , \"nbs\" , \"nbe\" ) @property def _urls ( self ) -> Iterator [ str ]: \"\"\" Iterates through hourly updates no older than two days \"\"\" date = dt . datetime . now ( tz = dt . timezone . utc ) cutoff = date - dt . timedelta ( days = 1 ) while date > cutoff : timestamp = date . strftime ( r \"%Y%m %d \" ) hour = str ( date . hour ) . zfill ( 2 ) yield self . url . format ( timestamp , hour , self . report_type , hour ) date -= dt . timedelta ( hours = 1 ) def _extract ( self , station : str , source : TextIO ) -> Optional [ str ]: \"\"\" Returns report pulled from the saved file \"\"\" start = station + \" \" end = self . report_type . upper () + \" GUIDANCE\" txt = source . read () txt = txt [ txt . find ( start ) :] txt = txt [: txt . find ( end , 30 )] lines = [] for line in txt . split ( \" \\n \" ): if \"CLIMO\" not in line : line = line . strip () if not line : break lines . append ( line ) return \" \\n \" . join ( lines ) or None In this example, we iterate through _urls looking for the most recent published file. URL iterators should always have a lower bound to stop iteration so the service can return a null response. Once the file is downloaded, the requested station and file-like object are passed to the _extract method to find and return the report from the file. This method will not be called if the file doesn't exist.","title":"FileService"},{"location":"util/static/","text":"Static Values Contains static objects for internal and external use Station Identification METAR and TAF reports come in two variants depending on the station's location: North American & International. This affects both element parsing and inferred units of measurement. AVWX determines this by looking at the station's ICAO value. avwx.static.core. NA_REGIONS : [str] Prefix indicating station uses North American formatting avwx.static.core. IN_REGIONS : [str] Prefix indicating station uses International formatting avwx.static.core. M_NA_REGIONS : [str] Two-character prefix indication Central American station uses North American formatting avwx.static.core. M_IN_REGIONS : [str] Two-character prefix indication Central American station uses International formatting Translations Static values used to translate report data avwx.static.core. CLOUD_TRANSLATIONS : {str: str} Dictionary associating cloud layer and cloud codes with descriptions avwx.static.taf. ICING_CONDITIONS : {str: str} Dictionary associating icing report IDs with descriptions avwx.static.taf. PRESSURE_TENDENCIES : {str: str} Dictionary associating pressure change IDs with descriptions avwx.static.core. REMARKS_ELEMENTS : {str: str} Static remarks translation elements avwx.static.core. REMARKS_GROUPS : {str: str} Static remarks translation group strings avwx.static.taf. TURBULENCE_CONDITIONS : {str: str} Dictionary associating turbulence report IDs with descriptions avwx.static.core. WX_TRANSLATIONS : {str: str} Dictionary associating WX codes with descriptions Units Static values involving units of measure avwx.static.core. CARDINALS : {str: int} Dictionary of cardinal direction values avwx.static.core. CLOUD_LIST : [str] List of cloud layer abbreviations avwx.static.core. FLIGHT_RULES : [str] List of flight rules abbreviations avwx.static.core. FRACTIONS : {str: str} Dictionary associating fraction strings with their spoken version avwx.static.core. IN_UNITS : {str: str} International variant units avwx.static.core. NA_UNITS : {str: str} North American variant units avwx.static.core. NUMBER_REPL : {str: str} Dictionary associating algebraic signs with their spoken version avwx.static.core. SPECIAL_NUMBERS : {str: tuple} Dictionary associating special number values with their spoken version avwx.static.core. SPOKEN_UNITS : {str: str} Units required to be translated in order to be spoken properly","title":"Static Values"},{"location":"util/static/#static-values","text":"Contains static objects for internal and external use","title":"Static Values"},{"location":"util/static/#station-identification","text":"METAR and TAF reports come in two variants depending on the station's location: North American & International. This affects both element parsing and inferred units of measurement. AVWX determines this by looking at the station's ICAO value.","title":"Station Identification"},{"location":"util/static/#avwxstaticcorena_regions-str","text":"Prefix indicating station uses North American formatting","title":"avwx.static.core.NA_REGIONS: [str]"},{"location":"util/static/#avwxstaticcorein_regions-str","text":"Prefix indicating station uses International formatting","title":"avwx.static.core.IN_REGIONS: [str]"},{"location":"util/static/#avwxstaticcorem_na_regions-str","text":"Two-character prefix indication Central American station uses North American formatting","title":"avwx.static.core.M_NA_REGIONS: [str]"},{"location":"util/static/#avwxstaticcorem_in_regions-str","text":"Two-character prefix indication Central American station uses International formatting","title":"avwx.static.core.M_IN_REGIONS: [str]"},{"location":"util/static/#translations","text":"Static values used to translate report data","title":"Translations"},{"location":"util/static/#avwxstaticcorecloud_translations-str-str","text":"Dictionary associating cloud layer and cloud codes with descriptions","title":"avwx.static.core.CLOUD_TRANSLATIONS: {str: str}"},{"location":"util/static/#avwxstatictaficing_conditions-str-str","text":"Dictionary associating icing report IDs with descriptions","title":"avwx.static.taf.ICING_CONDITIONS: {str: str}"},{"location":"util/static/#avwxstatictafpressure_tendencies-str-str","text":"Dictionary associating pressure change IDs with descriptions","title":"avwx.static.taf.PRESSURE_TENDENCIES: {str: str}"},{"location":"util/static/#avwxstaticcoreremarks_elements-str-str","text":"Static remarks translation elements","title":"avwx.static.core.REMARKS_ELEMENTS: {str: str}"},{"location":"util/static/#avwxstaticcoreremarks_groups-str-str","text":"Static remarks translation group strings","title":"avwx.static.core.REMARKS_GROUPS: {str: str}"},{"location":"util/static/#avwxstatictafturbulence_conditions-str-str","text":"Dictionary associating turbulence report IDs with descriptions","title":"avwx.static.taf.TURBULENCE_CONDITIONS: {str: str}"},{"location":"util/static/#avwxstaticcorewx_translations-str-str","text":"Dictionary associating WX codes with descriptions","title":"avwx.static.core.WX_TRANSLATIONS: {str: str}"},{"location":"util/static/#units","text":"Static values involving units of measure","title":"Units"},{"location":"util/static/#avwxstaticcorecardinals-str-int","text":"Dictionary of cardinal direction values","title":"avwx.static.core.CARDINALS: {str: int}"},{"location":"util/static/#avwxstaticcorecloud_list-str","text":"List of cloud layer abbreviations","title":"avwx.static.core.CLOUD_LIST: [str]"},{"location":"util/static/#avwxstaticcoreflight_rules-str","text":"List of flight rules abbreviations","title":"avwx.static.core.FLIGHT_RULES: [str]"},{"location":"util/static/#avwxstaticcorefractions-str-str","text":"Dictionary associating fraction strings with their spoken version","title":"avwx.static.core.FRACTIONS: {str: str}"},{"location":"util/static/#avwxstaticcorein_units-str-str","text":"International variant units","title":"avwx.static.core.IN_UNITS: {str: str}"},{"location":"util/static/#avwxstaticcorena_units-str-str","text":"North American variant units","title":"avwx.static.core.NA_UNITS: {str: str}"},{"location":"util/static/#avwxstaticcorenumber_repl-str-str","text":"Dictionary associating algebraic signs with their spoken version","title":"avwx.static.core.NUMBER_REPL: {str: str}"},{"location":"util/static/#avwxstaticcorespecial_numbers-str-tuple","text":"Dictionary associating special number values with their spoken version","title":"avwx.static.core.SPECIAL_NUMBERS: {str: tuple}"},{"location":"util/static/#avwxstaticcorespoken_units-str-str","text":"Units required to be translated in order to be spoken properly","title":"avwx.static.core.SPOKEN_UNITS: {str: str}"},{"location":"util/station/","text":"Station This module contains station/airport dataclasses and search functions. For the purposes of AVWX, a station is any location that has an ICAO identification code. These are usually airports, but smaller locations might not generate certain report types or defer to larger stations nearby. For example, small airports with an AWOS system might not send the report to NOAA. They also include remote weather observation stations not associated with airports. class avwx.Station The Station dataclass stores basic info about the desired station and available Runways. The easiest way to get a station is to supply the ICAO code. IATA codes will also work with from_iata . >>> from avwx import Station >>> klex = Station . from_icao ( 'KLEX' ) >>> f \" { klex . name } in { klex . city } , { klex . state } \" 'Blue Grass Airport in Lexington, KY' >>> coord = round ( klex . latitude , 3 ), round ( klex . longitude , 3 ) >>> f \"Located at { coord } at { klex . elevation_ft } feet ( { klex . elevation_m } meters)\" 'Located at (38.036, -84.606) at 979 feet (298 meters)' >>> rw = max ( klex . runways , key = lambda r : r . length_ft ) >>> f \"Its longest runway is { rw . ident1 } / { rw . ident2 } at { rw . length_ft } feet\" 'Its longest runway is 04/22 at 7003 feet' This is also the same information you'd get from calling Report.station. >>> from avwx import Metar >>> klex = Metar ( 'KLEX' ) >>> klex . station . name 'Blue Grass Airport' city : str country : str distance ( lat: float, lon: float ) -> (float, float) : Returns the distance in miles and kilometers from a given lat,lon elevation_ft : int Elevation in feet elevation_m : int Elevation in meters from_icao ( ident: str ) -> Station Load a Station from an ICAO station ident from_iata ( ident: str ) -> Station Load a Station from an IATA code iata : str Station's 3-char IATA ident icao : str Station's 4-char ICAO ident latitude : float longitude : float name : str Station / airport name nearest ( lat: float, lon: float, is_airport: bool = False, sends_reports: bool = True max_distance: float = 50 ) -> (avwx.Station, dict) Load the Station nearest to a lat,lon coordinate pair Returns the Station and coordinate distance from source NOTE: Becomes less accurate toward poles and doesn't cross +/-180 note : str Location notes like nearby landmarks runways : [avwx.station.Runway] List of available Runway objects sorted longest to shortest state : str type : str Station / airport type like \"large_airport\" website : str Station / airport primary website wiki : str Station Wikipedia page class avwx.station.Runway Represents a runway at an airport length_ft : int Runway length in feet width_ft : int Runway width in feet ident1 : str Runway number 01-18 with modifiers. Ex: \"17L\" ident2 : str Runway number 19-36 with modifiers. Ex: \"35R\" avwx.station. station_list ( reporting: bool = True ) -> [str] : Returns a list of station idents matching the search criteria avwx.station. nearest ( lat: float, lon: float, n: int = 1, is_airport: bool = False, sends_reports: bool = True, max_distance: float = 10 ) -> [dict] Finds the nearest n Stations to a lat,lon coordinate pair Returns the Station and coordinate distance from source NOTE: Becomes less accurate toward poles and doesn't cross +/-180","title":"Station"},{"location":"util/station/#station","text":"This module contains station/airport dataclasses and search functions. For the purposes of AVWX, a station is any location that has an ICAO identification code. These are usually airports, but smaller locations might not generate certain report types or defer to larger stations nearby. For example, small airports with an AWOS system might not send the report to NOAA. They also include remote weather observation stations not associated with airports.","title":"Station"},{"location":"util/station/#class-avwxstation","text":"The Station dataclass stores basic info about the desired station and available Runways. The easiest way to get a station is to supply the ICAO code. IATA codes will also work with from_iata . >>> from avwx import Station >>> klex = Station . from_icao ( 'KLEX' ) >>> f \" { klex . name } in { klex . city } , { klex . state } \" 'Blue Grass Airport in Lexington, KY' >>> coord = round ( klex . latitude , 3 ), round ( klex . longitude , 3 ) >>> f \"Located at { coord } at { klex . elevation_ft } feet ( { klex . elevation_m } meters)\" 'Located at (38.036, -84.606) at 979 feet (298 meters)' >>> rw = max ( klex . runways , key = lambda r : r . length_ft ) >>> f \"Its longest runway is { rw . ident1 } / { rw . ident2 } at { rw . length_ft } feet\" 'Its longest runway is 04/22 at 7003 feet' This is also the same information you'd get from calling Report.station. >>> from avwx import Metar >>> klex = Metar ( 'KLEX' ) >>> klex . station . name 'Blue Grass Airport'","title":"class avwx.Station"},{"location":"util/station/#city-str","text":"","title":"city: str"},{"location":"util/station/#country-str","text":"","title":"country: str"},{"location":"util/station/#distancelat-float-lon-float-float-float","text":"Returns the distance in miles and kilometers from a given lat,lon","title":"distance(lat: float, lon: float) -&gt; (float, float):"},{"location":"util/station/#elevation_ft-int","text":"Elevation in feet","title":"elevation_ft: int"},{"location":"util/station/#elevation_m-int","text":"Elevation in meters","title":"elevation_m: int"},{"location":"util/station/#from_icaoident-str-station","text":"Load a Station from an ICAO station ident","title":"from_icao(ident: str) -&gt; Station"},{"location":"util/station/#from_iataident-str-station","text":"Load a Station from an IATA code","title":"from_iata(ident: str) -&gt; Station"},{"location":"util/station/#iata-str","text":"Station's 3-char IATA ident","title":"iata: str"},{"location":"util/station/#icao-str","text":"Station's 4-char ICAO ident","title":"icao: str"},{"location":"util/station/#latitude-float","text":"","title":"latitude: float"},{"location":"util/station/#longitude-float","text":"","title":"longitude: float"},{"location":"util/station/#name-str","text":"Station / airport name","title":"name: str"},{"location":"util/station/#nearestlat-float-lon-float-is_airport-bool-false-sends_reports-bool-true-max_distance-float-50-avwxstation-dict","text":"Load the Station nearest to a lat,lon coordinate pair Returns the Station and coordinate distance from source NOTE: Becomes less accurate toward poles and doesn't cross +/-180","title":"nearest(lat: float, lon: float, is_airport: bool = False, sends_reports: bool = True max_distance: float = 50) -&gt; (avwx.Station, dict)"},{"location":"util/station/#note-str","text":"Location notes like nearby landmarks","title":"note: str"},{"location":"util/station/#runways-avwxstationrunway","text":"List of available Runway objects sorted longest to shortest","title":"runways: [avwx.station.Runway]"},{"location":"util/station/#state-str","text":"","title":"state: str"},{"location":"util/station/#type-str","text":"Station / airport type like \"large_airport\"","title":"type: str"},{"location":"util/station/#website-str","text":"Station / airport primary website","title":"website: str"},{"location":"util/station/#wiki-str","text":"Station Wikipedia page","title":"wiki: str"},{"location":"util/station/#class-avwxstationrunway","text":"Represents a runway at an airport","title":"class avwx.station.Runway"},{"location":"util/station/#length_ft-int","text":"Runway length in feet","title":"length_ft: int"},{"location":"util/station/#width_ft-int","text":"Runway width in feet","title":"width_ft: int"},{"location":"util/station/#ident1-str","text":"Runway number 01-18 with modifiers. Ex: \"17L\"","title":"ident1: str"},{"location":"util/station/#ident2-str","text":"Runway number 19-36 with modifiers. Ex: \"35R\"","title":"ident2: str"},{"location":"util/station/#avwxstationstation_listreporting-bool-true-str","text":"Returns a list of station idents matching the search criteria","title":"avwx.station.station_list(reporting: bool = True) -&gt; [str]:"},{"location":"util/station/#avwxstationnearestlat-float-lon-float-n-int-1-is_airport-bool-false-sends_reports-bool-true-max_distance-float-10-dict","text":"Finds the nearest n Stations to a lat,lon coordinate pair Returns the Station and coordinate distance from source NOTE: Becomes less accurate toward poles and doesn't cross +/-180","title":"avwx.station.nearest(lat: float, lon: float, n: int = 1, is_airport: bool = False, sends_reports: bool = True, max_distance: float = 10) -&gt; [dict]"},{"location":"util/structs/","text":"Other Data Structures class avwx.structs. Aircraft from_icao ( code: str ) -> avwx.structs.Aircraft Load an Aircraft from an ICAO aircraft code code : str type : str class avwx.structs. Cloud base : int = None direction : str = None modifier : str = None repr : str top : int = None type : str = str class avwx.structs. Code repr : str value : str class avwx.structs. Fraction denominator : int normalized : str numerator : int class avwx.structs. Icing ceiling : avwx.structs.Number = None floor : avwx.structs.Number = None severity : str type : str = None class avwx.structs. Location direction : avwx.structs.Number distance : avwx.structs.Number repr : str station : str class avwx.structs. Number repr : str spoken : str value : float class avwx.structs. PressureTendency repr : str tendency : str change : float class avwx.structs. RemarksData codes : List[avwx.structs.Code] = [] dewpoint_decimal : avwx.structs.Number = None maximum_temperature_24 : avwx.structs.Number = None maximum_temperature_6 : avwx.structs.Number = None minimum_temperature_24 : avwx.structs.Number = None minimum_temperature_6 : avwx.structs.Number = None precip_24_hours : avwx.structs.Number = None precip_36_hours : avwx.structs.Number = None precip_hourly : avwx.structs.Number = None pressure_tendency : avwx.structs.PressureTendency = None sea_level_pressure : avwx.structs.Number = None snow_depth : avwx.structs.Number = None sunshine_minutes : avwx.structs.Number = None temperature_decimal : avwx.structs.Number = None class avwx.structs. Timestamp dt : datetime.datetime repr : str class avwx.structs. Turbulence ceiling : avwx.structs.Number = None floor : avwx.structs.Number = None severity : str class avwx.structs. Units accumulation : str altimeter : str altitude : str temperature : str visibility : str wind_speed : str class avwx.structs. NbmUnits : accumulation : str altimeter : str altitude : str duration : str solar_radiation : str temperature : str visibility : str wave_height : str wind_speed : str","title":"Data Structures"},{"location":"util/structs/#other-data-structures","text":"","title":"Other Data Structures"},{"location":"util/structs/#class-avwxstructsaircraft","text":"","title":"class avwx.structs.Aircraft"},{"location":"util/structs/#from_icaocode-str-avwxstructsaircraft","text":"Load an Aircraft from an ICAO aircraft code code : str type : str","title":"from_icao(code: str) -&gt; avwx.structs.Aircraft"},{"location":"util/structs/#class-avwxstructscloud","text":"base : int = None direction : str = None modifier : str = None repr : str top : int = None type : str = str","title":"class avwx.structs.Cloud"},{"location":"util/structs/#class-avwxstructscode","text":"repr : str value : str","title":"class avwx.structs.Code"},{"location":"util/structs/#class-avwxstructsfraction","text":"denominator : int normalized : str numerator : int","title":"class avwx.structs.Fraction"},{"location":"util/structs/#class-avwxstructsicing","text":"ceiling : avwx.structs.Number = None floor : avwx.structs.Number = None severity : str type : str = None","title":"class avwx.structs.Icing"},{"location":"util/structs/#class-avwxstructslocation","text":"direction : avwx.structs.Number distance : avwx.structs.Number repr : str station : str","title":"class avwx.structs.Location"},{"location":"util/structs/#class-avwxstructsnumber","text":"repr : str spoken : str value : float","title":"class avwx.structs.Number"},{"location":"util/structs/#class-avwxstructspressuretendency","text":"repr : str tendency : str change : float","title":"class avwx.structs.PressureTendency"},{"location":"util/structs/#class-avwxstructsremarksdata","text":"codes : List[avwx.structs.Code] = [] dewpoint_decimal : avwx.structs.Number = None maximum_temperature_24 : avwx.structs.Number = None maximum_temperature_6 : avwx.structs.Number = None minimum_temperature_24 : avwx.structs.Number = None minimum_temperature_6 : avwx.structs.Number = None precip_24_hours : avwx.structs.Number = None precip_36_hours : avwx.structs.Number = None precip_hourly : avwx.structs.Number = None pressure_tendency : avwx.structs.PressureTendency = None sea_level_pressure : avwx.structs.Number = None snow_depth : avwx.structs.Number = None sunshine_minutes : avwx.structs.Number = None temperature_decimal : avwx.structs.Number = None","title":"class avwx.structs.RemarksData"},{"location":"util/structs/#class-avwxstructstimestamp","text":"dt : datetime.datetime repr : str","title":"class avwx.structs.Timestamp"},{"location":"util/structs/#class-avwxstructsturbulence","text":"ceiling : avwx.structs.Number = None floor : avwx.structs.Number = None severity : str","title":"class avwx.structs.Turbulence"},{"location":"util/structs/#class-avwxstructsunits","text":"accumulation : str altimeter : str altitude : str temperature : str visibility : str wind_speed : str","title":"class avwx.structs.Units"},{"location":"util/structs/#class-avwxstructsnbmunits","text":"accumulation : str altimeter : str altitude : str duration : str solar_radiation : str temperature : str visibility : str wave_height : str wind_speed : str","title":"class avwx.structs.NbmUnits:"}]}